// Windjammer Testing Framework - Beginner Examples
// 
// This file shows practical examples of all testing features.
// Copy and adapt these examples for your own tests!

use std::test::*;
use std::bench::*;
use std::property::*;
use std::mock::*;
use std::contracts::*;
use std::fixtures::*;

// ============================================================================
// 1. BASIC ASSERTIONS - Testing values and conditions
// ============================================================================

@test
fn example_basic_assertions() {
    // Equality
    let score = 100;
    assert_eq(score, 100);           // Values are equal
    assert_ne(score, 50);            // Values are not equal
    
    // Comparisons
    let health = 75;
    assert_gt(health, 50);           // Greater than
    assert_lt(health, 100);          // Less than
    assert_gte(health, 75);          // Greater than or equal
    assert_lte(health, 75);          // Less than or equal
    
    // Floating-point comparison
    let pi = 3.14159;
    assert_approx(pi, 3.14159, 0.00001);  // Approximately equal
    
    // Ranges
    let level = 5;
    assert_in_range(level, 1, 10);   // Value is between 1 and 10
}

@test
fn example_collection_assertions() {
    let items = vec!["sword", "shield", "potion"];
    
    // Check if collection contains item
    assert_contains(&items, &"sword");
    
    // Check if collection is empty
    let empty: Vec<string> = vec![];
    assert_empty(&empty);
    assert_not_empty(&items);
}

@test
fn example_string_assertions() {
    let message = "Player has entered the dungeon";
    
    // String contains substring
    assert_str_contains(message, "dungeon");
    
    // String starts/ends with
    assert_starts_with(message, "Player");
    assert_ends_with(message, "dungeon");
}

@test
fn example_option_result_assertions() {
    // Testing Option types
    let found_item = Some("key");
    let missing_item: Option<string> = None;
    
    assert_is_some(&found_item);
    assert_is_none(&missing_item);
    
    // Testing Result types
    let success: Result<int, string> = Ok(42);
    let failure: Result<int, string> = Err("failed");
    
    assert_is_ok(&success);
    assert_is_err(&failure);
}

// ============================================================================
// 2. ADVANCED ASSERTIONS - Testing complex behavior
// ============================================================================

@test
fn example_panic_assertion() {
    // Verify that code panics
    assert_panics(|| {
        let x = 10 / 0;  // This will panic
    });
}

@test
fn example_panic_with_message() {
    // Verify panic message contains specific text
    assert_panics_with("division by zero", || {
        panic!("division by zero error");
    });
}

struct GameState {
    level: int,
    score: int,
}

@test
fn example_deep_equality() {
    let state1 = GameState { level: 5, score: 1000 };
    let state2 = GameState { level: 5, score: 1000 };
    
    // Deep structural comparison
    assert_deep_eq(state1, state2);
}

// ============================================================================
// 3. PARAMETERIZED TESTS - Test multiple inputs
// ============================================================================

// Example: Testing damage calculation with multiple values
@test_cases([
    (100, 10, 90),   // health=100, damage=10, expected=90
    (100, 50, 50),   // health=100, damage=50, expected=50
    (100, 150, 0),   // health=100, damage=150, expected=0 (clamped)
    (50, 25, 25),    // health=50, damage=25, expected=25
])
fn example_damage_calculation(initial_health: int, damage: int, expected_health: int) {
    let mut health = initial_health;
    health -= damage;
    if health < 0 {
        health = 0;  // Clamp to 0
    }
    assert_eq(health, expected_health);
}

// Example: Testing string operations
@test_cases([
    ("hello", "HELLO"),
    ("world", "WORLD"),
    ("Windjammer", "WINDJAMMER"),
])
fn example_uppercase_conversion(input: string, expected: string) {
    let result = input.to_uppercase();
    assert_eq(result, expected);
}

// Example: Testing math operations
@test_cases([
    (0, 0, 0),
    (1, 1, 1),
    (5, 3, 15),
    (-2, 4, -8),
])
fn example_multiplication(a: int, b: int, expected: int) {
    assert_eq(a * b, expected);
}

// ============================================================================
// 4. SKIPPING TESTS - Temporarily disable tests
// ============================================================================

@test
@ignore  // This test will be skipped
fn example_expensive_test() {
    // This test takes too long, so we ignore it for now
    for i in 0..1000000 {
        let x = i * i;
    }
}

@test
@ignore  // Skip during development
fn example_not_ready_yet() {
    // This feature isn't implemented yet
    // TODO: Implement multiplayer logic
}

// ============================================================================
// 5. BENCHMARKING - Measure performance
// ============================================================================

fn render_sprite(x: int, y: int) -> bool {
    // Simulate rendering
    let result = x * y;
    result > 0
}

@test
fn example_simple_benchmark() {
    // Measure average time over 1000 runs
    let avg_time = bench_iterations(1000, || {
        render_sprite(10, 20);
    });
    
    println!("Average render time: {:?}", avg_time);
}

@test
fn example_single_benchmark() {
    // Measure a single run
    let time = bench(|| {
        for i in 0..100 {
            render_sprite(i, i);
        }
    });
    
    println!("Total time: {:?}", time);
}

fn old_pathfinding(start: int, end: int) -> int {
    // Slow algorithm
    let mut result = 0;
    for i in start..end {
        result += i;
    }
    result
}

fn new_pathfinding(start: int, end: int) -> int {
    // Fast algorithm (using formula)
    (end - start) * (start + end - 1) / 2
}

@test
fn example_compare_benchmarks() {
    // Compare two implementations
    let (old_time, new_time, speedup) = bench_compare(
        || old_pathfinding(0, 1000),
        || new_pathfinding(0, 1000),
        100  // Run 100 times each
    );
    
    println!("Old: {:?}, New: {:?}, Speedup: {:.2}x", old_time, new_time, speedup);
}

// ============================================================================
// 6. PROPERTY-BASED TESTING - Test properties with many inputs
// ============================================================================

@test
fn example_commutative_property() {
    // Test that addition is commutative: a + b = b + a
    let iterations = 100;
    for i in 0..iterations {
        let a = (i * 13) % 1000;
        let b = (i * 17) % 1000;
        assert_eq(a + b, b + a);
    }
}

@test
fn example_associative_property() {
    // Test that addition is associative: (a + b) + c = a + (b + c)
    let iterations = 100;
    for i in 0..iterations {
        let a = (i * 13) % 1000;
        let b = (i * 17) % 1000;
        let c = (i * 19) % 1000;
        assert_eq((a + b) + c, a + (b + c));
    }
}

@test
fn example_identity_property() {
    // Test that 0 is the additive identity: a + 0 = a
    let iterations = 100;
    for i in 0..iterations {
        let a = (i * 13) % 1000;
        assert_eq(a + 0, a);
        assert_eq(0 + a, a);
    }
}

// ============================================================================
// 7. TEST OUTPUT - Format test results
// ============================================================================

@test
fn example_test_output() {
    let mut summary = TestSummary::new();
    
    // Add some test results
    let result1 = TestResult::new(
        "test_player_move".to_string(),
        TestStatus::Passed,
        Duration::from_millis(5)
    );
    
    let result2 = TestResult::new(
        "test_collision".to_string(),
        TestStatus::Failed,
        Duration::from_millis(10)
    ).with_error("Expected collision at (10, 20)".to_string());
    
    summary.add_result(result1);
    summary.add_result(result2);
    
    // Format output
    println!("{}", summary.format_standard());
    // Output:
    // âœ“ test_player_move (5ms)
    // âœ— test_collision (10ms)
    //   Expected collision at (10, 20)
}

// ============================================================================
// 8. TIMEOUT - Ensure tests complete in time
// ============================================================================

@test
fn example_timeout_success() {
    // This completes quickly, so it passes
    let result = with_timeout(Duration::from_secs(1), || {
        let mut sum = 0;
        for i in 0..1000 {
            sum += i;
        }
        sum
    });
    
    assert!(result.is_ok());
}

@test
fn example_timeout_for_frame_budget() {
    // Ensure rendering completes within 16ms (60fps)
    let result = with_timeout(Duration::from_millis(16), || {
        // Simulate rendering
        render_sprite(10, 20);
    });
    
    assert!(result.is_ok());  // Must complete in time!
}

// ============================================================================
// 9. SETUP/TEARDOWN - Manage test lifecycle
// ============================================================================

struct TestDatabase {
    connected: bool,
    data: Vec<string>,
}

impl TestDatabase {
    fn new() -> Self {
        Self {
            connected: true,
            data: vec!["user1", "user2", "user3"],
        }
    }
    
    fn disconnect(&mut self) {
        self.connected = false;
        self.data.clear();
    }
}

@test
fn example_with_setup() {
    // Setup: Create database
    let result = with_setup(
        || TestDatabase::new(),
        |db| {
            // Test: Query database
            assert(db.connected);
            assert_eq(db.data.len(), 3);
            db
        }
    );
}

@test
fn example_with_setup_teardown() {
    fn setup() -> TestDatabase {
        TestDatabase::new()
    }
    
    fn teardown(mut db: TestDatabase) {
        db.disconnect();
    }
    
    // Run test with automatic cleanup
    with_setup_teardown(setup, teardown, |mut db| {
        // Test code
        assert(db.connected);
        assert_eq(db.data.len(), 3);
        
        // db is automatically cleaned up after test
        db
    });
}

// ============================================================================
// 10. FIXTURES - Reusable test resources
// ============================================================================

struct TestLevel {
    name: string,
    width: int,
    height: int,
}

impl TestLevel {
    fn new() -> Self {
        Self {
            name: "test_level",
            width: 100,
            height: 100,
        }
    }
}

@test
fn example_fixture_registration() {
    // Register fixtures once, use in many tests
    register_fixture("test_level", || TestLevel::new());
    register_fixture("test_player", || Player::new());
}

@test
fn example_using_fixture() {
    // First, register the fixture (usually done in test setup)
    register_fixture("test_level", || TestLevel::new());
    
    // Use the fixture in your test
    let level = use_fixture::<TestLevel>("test_level").unwrap();
    assert_eq(level.name, "test_level");
    assert_eq(level.width, 100);
}

@test
fn example_fixture_scope() {
    // Fixture with automatic cleanup
    let mut scope = FixtureScope::new(TestLevel::new());
    let level = scope.get();
    
    assert_eq(level.width, 100);
    
    // Scope is automatically cleaned up when it goes out of scope
}

// ============================================================================
// 11. DOC TESTS - Tests in documentation
// ============================================================================

/// Calculate the distance between two points.
///
/// # Example
/// ```
/// let distance = calculate_distance(0.0, 0.0, 3.0, 4.0);
/// assert_approx(distance, 5.0, 0.001);
/// ```
fn calculate_distance(x1: float, y1: float, x2: float, y2: float) -> float {
    let dx = x2 - x1;
    let dy = y2 - y1;
    (dx * dx + dy * dy).sqrt()
}

/// Apply damage to a player.
///
/// # Example
/// ```
/// let mut health = 100;
/// health = apply_damage(health, 30);
/// assert_eq(health, 70);
/// ```
fn apply_damage(health: int, damage: int) -> int {
    let new_health = health - damage;
    if new_health < 0 { 0 } else { new_health }
}

// ============================================================================
// 12. DESIGN-BY-CONTRACT - Formal verification
// ============================================================================

@test
fn example_preconditions() {
    fn divide(a: int, b: int) -> int {
        // Precondition: divisor must not be zero
        requires(b != 0, "divisor must be non-zero");
        a / b
    }
    
    let result = divide(10, 2);
    assert_eq(result, 5);
    
    // This would panic with precondition violation:
    // let bad = divide(10, 0);
}

@test
fn example_postconditions() {
    fn abs(x: int) -> int {
        let result = if x < 0 { -x } else { x };
        
        // Postcondition: result must be non-negative
        ensures(result >= 0, "result must be non-negative");
        
        result
    }
    
    assert_eq(abs(-5), 5);
    assert_eq(abs(5), 5);
}

struct Counter {
    count: int,
}

impl Counter {
    fn new() -> Self {
        Self { count: 0 }
    }
    
    fn increment(&mut self) {
        self.count += 1;
        
        // Invariant: count should always be positive
        invariant(self.count > 0, "count must be positive after increment");
    }
}

@test
fn example_invariants() {
    let mut counter = Counter::new();
    counter.increment();
    assert_eq(counter.count, 1);
}

@test
fn example_contract_builder() {
    fn safe_divide(a: int, b: int) -> int {
        let contract = Contract::new()
            .requires(b != 0, "divisor must be non-zero")
            .requires(a >= 0, "dividend must be non-negative")
            .ensures(true, "result is valid");
        
        contract.check_preconditions();
        let result = a / b;
        contract.check_postconditions();
        
        result
    }
    
    assert_eq(safe_divide(10, 2), 5);
}

// ============================================================================
// 13. BASIC MOCKING - Track calls and returns
// ============================================================================

@test
fn example_mock_tracker() {
    let tracker = MockTracker::new();
    
    // Simulate function calls
    tracker.record_call("load_texture", vec!["player.png"]);
    tracker.record_call("load_texture", vec!["enemy.png"]);
    tracker.record_call("play_sound", vec!["shoot.wav"]);
    
    // Verify calls
    assert_eq(tracker.call_count("load_texture"), 2);
    assert_eq(tracker.call_count("play_sound"), 1);
    
    tracker.verify_called("load_texture");
    tracker.verify_called_times("load_texture", 2);
}

@test
fn example_mock_return_values() {
    // Mock returns values in sequence (FIFO)
    let mock = MockReturn::new(vec![10, 20, 30]);
    
    assert_eq(mock.next(), Some(10));
    assert_eq(mock.next(), Some(20));
    assert_eq(mock.next(), Some(30));
    assert_eq(mock.next(), None);  // No more values
}

// ============================================================================
// 14. INTERFACE MOCKING - Mock traits/interfaces
// ============================================================================

@test
fn example_mock_object() {
    let mock = MockObject::new();
    
    // Set expectations
    let expectation = Expectation::new("query")
        .with_args(vec!["SELECT * FROM users"])
        .times(1);
    
    mock.expect(expectation);
    
    // Simulate calls
    mock.record_call("query", vec!["SELECT * FROM users"]);
    
    // Verify expectations met
    mock.verify();
}

@test
fn example_mock_with_returns() {
    let mock = MockObject::new();
    
    // Configure return values
    mock.set_return("get_health", 100);
    mock.set_return("get_health", 75);
    
    // Use mock
    let health1: Option<int> = mock.get_return("get_health");
    let health2: Option<int> = mock.get_return("get_health");
    
    assert_eq(health1, Some(100));
    assert_eq(health2, Some(75));
}

// ============================================================================
// 15. FUNCTION MOCKING - Mock global functions
// ============================================================================

@test
fn example_function_mock() {
    // Mock a function temporarily
    with_mock("get_current_time", || 12345, || {
        // Inside this scope, get_current_time() returns 12345
        // (assuming the function checks for mocks)
        
        // Test time-dependent code
        assert(true);  // Placeholder
    });
    
    // Mock is automatically cleared after scope
}

@test
fn example_mock_registry() {
    let mut registry = MockRegistry::new();
    
    // Record function calls
    registry.record_call("load_asset");
    registry.record_call("load_asset");
    registry.record_call("save_game");
    
    // Verify calls
    assert_eq(registry.call_count("load_asset"), 2);
    assert(registry.was_called("save_game"));
    
    registry.verify_called_times("load_asset", 2);
}

// ============================================================================
// 16. COMPLETE EXAMPLE - Game testing with all features
// ============================================================================

struct Player {
    health: int,
    position_x: float,
    position_y: float,
    inventory: Vec<string>,
}

impl Player {
    fn new() -> Self {
        Self {
            health: 100,
            position_x: 0.0,
            position_y: 0.0,
            inventory: vec![],
        }
    }
    
    fn take_damage(&mut self, amount: int) {
        // Contract: damage must be non-negative
        requires(amount >= 0, "damage must be non-negative");
        
        let old_health = self.health;
        self.health -= amount;
        if self.health < 0 {
            self.health = 0;
        }
        
        // Contract: health should never increase from damage
        ensures(self.health <= old_health, "health should not increase");
        
        // Invariant: health is always non-negative
        invariant(self.health >= 0, "health must be non-negative");
    }
    
    fn move_to(&mut self, x: float, y: float) {
        requires(self.health > 0, "dead players can't move");
        self.position_x = x;
        self.position_y = y;
    }
    
    fn add_item(&mut self, item: string) {
        self.inventory.push(item);
        invariant(self.inventory.len() > 0, "inventory not empty");
    }
}

// Parameterized damage tests
@test_cases([
    (10, 90),
    (50, 50),
    (100, 0),
    (150, 0),  // Over-damage clamped to 0
])
fn example_player_damage(damage: int, expected_health: int) {
    let mut player = Player::new();
    player.take_damage(damage);
    assert_eq(player.health, expected_health);
}

// Property: Health never negative
@test
fn example_player_health_property() {
    let iterations = 100;
    for i in 0..iterations {
        let damage = (i * 13) % 200;  // Random damage 0-200
        let mut player = Player::new();
        player.take_damage(damage);
        
        // Property: health is always >= 0
        assert_gte(player.health, 0);
    }
}

// Movement with fixtures
@test
fn example_player_movement_with_fixture() {
    register_fixture("player", || Player::new());
    
    let mut player = use_fixture::<Player>("player").unwrap();
    assert_approx(player.position_x, 0.0, 0.001);
    
    player.move_to(10.5, 20.3);
    assert_approx(player.position_x, 10.5, 0.001);
    assert_approx(player.position_y, 20.3, 0.001);
}

// Inventory tests
@test
fn example_player_inventory() {
    let mut player = Player::new();
    assert_empty(&player.inventory);
    
    player.add_item("sword");
    player.add_item("shield");
    
    assert_eq(player.inventory.len(), 2);
    assert_contains(&player.inventory, &"sword");
    assert_contains(&player.inventory, &"shield");
}

// Benchmark player operations
@test
fn example_player_benchmark() {
    let avg_time = bench_iterations(1000, || {
        let mut player = Player::new();
        player.take_damage(10);
        player.move_to(5.0, 5.0);
        player.add_item("potion");
    });
    
    println!("Average player operation time: {:?}", avg_time);
}

// ============================================================================
// SUMMARY
// ============================================================================
//
// This file demonstrates:
// 1. âœ… Basic assertions - Testing values, collections, strings, options
// 2. âœ… Advanced assertions - Panics, deep equality, type checking
// 3. âœ… Parameterized tests - Table-driven testing
// 4. âœ… @ignore - Skipping tests
// 5. âœ… Benchmarking - Performance measurement
// 6. âœ… Property testing - Testing properties with many inputs
// 7. âœ… Test output - Formatting results
// 8. âœ… Timeout - Time limits for tests
// 9. âœ… Setup/Teardown - Test lifecycle management
// 10. âœ… Fixtures - Reusable test resources
// 11. âœ… Doc tests - Tests in documentation
// 12. âœ… Contracts - Formal verification
// 13. âœ… Basic mocking - Call tracking and return values
// 14. âœ… Interface mocking - Mock objects
// 15. âœ… Function mocking - Mock global functions
// 16. âœ… Complete example - Real game testing
//
// Copy any of these examples and adapt them for your tests!
// The framework is designed to be simple and intuitive.
//
// Happy testing! ðŸš€

