// Example 25: Where Clauses
// Demonstrates complex trait constraints using where clauses

// Simple where clause for better readability
fn print_both<T, U>(first: T, second: U)
where
    T: Display,
    U: Display
{
    println!("First: {}", first)
    println!("Second: {}", second)
}

// Complex where clause with multiple bounds
fn display_and_clone<T, U>(a: T, b: U)
where
    T: Display + Clone,
    U: Display + Clone
{
    let a_copy = a.clone()
    let b_copy = b.clone()
    
    println!("A: {}", a)
    println!("A copy: {}", a_copy)
    println!("B: {}", b)
    println!("B copy: {}", b_copy)
}

// Struct with where clause
struct Pair<T, U>
where
    T: Clone,
    U: Clone
{
    first: T,
    second: U
}

impl<T, U> Pair<T, U>
where
    T: Clone + Display,
    U: Clone + Display
{
    fn display(&self) {
        println!("First: {}", self.first)
        println!("Second: {}", self.second)
    }
    
    fn clone_first(&self) -> T {
        self.first.clone()
    }
}

fn main() {
    println!("=== Where Clauses Example ===")
    
    // Test simple where clause
    println!("\n1. Simple where clause:")
    print_both(42, "Hello")
    
    // Test complex where clause with multiple bounds
    println!("\n2. Complex where clause (multiple bounds):")
    display_and_clone(100, "test")
    
    // Test struct with where clause
    println!("\n3. Struct with where clause:")
    let pair = Pair { first: 100, second: 200 }
    pair.display()
    let first_copy = pair.clone_first()
    println!("Cloned first: {}", first_copy)
    
    println!("\n=== Done ===")
}

