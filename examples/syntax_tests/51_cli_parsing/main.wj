// Example 51: CLI Argument Parsing
// Demonstrates Windjammer's std.cli module

use std::cli

// Define command-line arguments with @derive(Cli)
@derive(Cli, Debug)
struct Args {
    // Positional argument (required)
    @arg(help: "Input file to process")
    input: string,
    
    // Optional output file
    @arg(short: 'o', long: "output", help: "Output file (defaults to stdout)")
    output: Option<string>,
    
    // Verbose flag
    @arg(short: 'v', long: "verbose", help: "Enable verbose output")
    verbose: bool,
    
    // Count with default value
    @arg(short: 'n', long: "count", default_value: "10", help: "Number of items to process")
    count: int,
    
    // Format option
    @arg(short: 'f', long: "format", default_value: "json", help: "Output format (json, csv, xml)")
    format: string,
}

fn process_file(args: Args) {
    println!("=== Processing File ===")
    println!()
    println!("Configuration:")
    println!("  Input: {}", args.input)
    
    match args.output {
        Some(output) => println!("  Output: {}", output),
        None => println!("  Output: <stdout>")
    }
    
    println!("  Format: {}", args.format)
    println!("  Count: {}", args.count)
    println!("  Verbose: {}", args.verbose)
    println!()
    
    if args.verbose {
        println!("VERBOSE: Starting file processing...")
        println!("VERBOSE: Reading from '{}'", args.input)
    }
    
    // Simulate processing
    println!("Processing {} items from '{}'", args.count, args.input)
    
    if args.verbose {
        println!("VERBOSE: Processing complete")
    }
    
    match args.output {
        Some(output) => println!("Results written to '{}'", output),
        None => println!("Results printed to stdout")
    }
}

fn main() {
    println!("=== CLI Argument Parsing Demo ===")
    println!()
    
    // Get raw arguments for demo
    let raw_args = cli.args()
    println!("Raw arguments ({}): {:?}", raw_args.len(), raw_args)
    println!()
    
    // Parse structured arguments
    println!("Parsing arguments with std.cli...")
    println!()
    
    match cli.try_parse::<Args>() {
        Ok(args) => {
            println!("✓ Arguments parsed successfully!")
            println!()
            process_file(args)
        }
        Err(e) => {
            println!("✗ Error parsing arguments: {}", e)
            println!()
            println!("Usage:")
            println!("  {} <input> [OPTIONS]", raw_args.get(0).unwrap_or("program"))
            println!()
            println!("Arguments:")
            println!("  <input>                 Input file to process")
            println!()
            println!("Options:")
            println!("  -o, --output <FILE>     Output file (defaults to stdout)")
            println!("  -v, --verbose           Enable verbose output")
            println!("  -n, --count <N>         Number of items to process [default: 10]")
            println!("  -f, --format <FORMAT>   Output format (json, csv, xml) [default: json]")
            println!("  -h, --help             Print help information")
            println!()
            println!("Examples:")
            println!("  {} data.txt", raw_args.get(0).unwrap_or("program"))
            println!("  {} data.txt -o output.txt -v", raw_args.get(0).unwrap_or("program"))
            println!("  {} data.txt --count 20 --format csv", raw_args.get(0).unwrap_or("program"))
        }
    }
    
    println!()
    println!("✨ CLI parsing with Windjammer!")
    println!("   ✅ Using std.cli abstraction (not clap:: directly)")
    println!("   ✅ Clean, Windjammer-native API")
    println!("   ✅ @derive(Cli) for automatic parsing")
    println!("   ✅ @arg(...) decorator for argument configuration")
    println!("   ✅ Automatic help generation")
    println!()
    println!("Try running with different arguments:")
    println!("  cargo run -- data.txt")
    println!("  cargo run -- data.txt -v")
    println!("  cargo run -- data.txt -o output.txt --count 20")
    println!("  cargo run -- --help")
}
