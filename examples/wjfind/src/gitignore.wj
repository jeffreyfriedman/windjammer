// Simple .gitignore parser for wjfind

use std::fs
use std::path
use std::collections::HashSet

pub struct GitignoreRules {
    patterns: Vec<string>,
}

impl GitignoreRules {
    pub fn new() -> Self {
        GitignoreRules {
            patterns: vec![],
        }
    }
    
    pub fn load_from_directory(dir: string) -> Result<Self, Error> {
        let gitignore_path = path.join(dir, ".gitignore")
        
        if !fs.exists(gitignore_path.clone()) {
            return Ok(GitignoreRules::new())
        }
        
        let contents = fs.read_to_string(gitignore_path)?
        let mut patterns = vec![]
        
        for line in contents.lines() {
            let trimmed = line.trim()
            
            // Skip empty lines and comments
            if trimmed.is_empty() || trimmed.starts_with("#") {
                continue
            }
            
            patterns.push(trimmed.to_string())
        }
        
        Ok(GitignoreRules {
            patterns: patterns,
        })
    }
    
    pub fn is_ignored(self, path: string) -> bool {
        // Get the file/dir name from the path
        let name = path.file_name(path).unwrap_or(&path)
        let path_str = path.to_string()
        
        for pattern in self.patterns.iter() {
            if self.matches_pattern(name.clone(), pattern.clone()) 
                || self.matches_pattern(path_str.clone(), pattern.clone()) {
                return true
            }
        }
        
        false
    }
    
    fn matches_pattern(self, name: string, pattern: string) -> bool {
        // Simple matching (not full gitignore spec, but good enough)
        
        // Exact match
        if name == pattern {
            return true
        }
        
        // Directory match (ends with /)
        if pattern.ends_with("/") {
            let dir_pattern = pattern.trim_end_matches("/")
            if name == dir_pattern {
                return true
            }
        }
        
        // Wildcard match (*)
        if pattern.contains("*") {
            return self.wildcard_match(name, pattern)
        }
        
        // Extension match (*.ext)
        if pattern.starts_with("*.") {
            let ext = pattern.trim_start_matches("*.")
            if name.ends_with(&format!(".{}", ext)) {
                return true
            }
        }
        
        // Path contains pattern
        if name.contains(pattern) {
            return true
        }
        
        false
    }
    
    fn wildcard_match(self, name: string, pattern: string) -> bool {
        // Simple wildcard matching (* matches any characters)
        let parts: Vec<string> = pattern.split('*').collect()
        
        if parts.is_empty() {
            return false
        }
        
        // Check first part
        if !parts[0].is_empty() && !name.starts_with(parts[0]) {
            return false
        }
        
        // Check last part
        if parts.len() > 1 {
            let last = &parts[parts.len() - 1]
            if !last.is_empty() && !name.ends_with(last) {
                return false
            }
        }
        
        // Check middle parts (simplified - just check they exist in order)
        let mut pos = 0
        for (i, part) in parts.iter().enumerate() {
            if part.is_empty() {
                continue
            }
            
            if i == 0 {
                pos = part.len()
                continue
            }
            
            if let Some(idx) = name[pos..].find(part) {
                pos += idx + part.len()
            } else {
                return false
            }
        }
        
        true
    }
}

// Global cache of gitignore rules per directory
pub struct GitignoreCache {
    cache: std.collections.HashMap<string, GitignoreRules>,
}

impl GitignoreCache {
    pub fn new() -> Self {
        GitignoreCache {
            cache: std.collections.HashMap::new(),
        }
    }
    
    pub fn get_rules(self, dir: string) -> GitignoreRules {
        if let Some(rules) = self.cache.get(&dir) {
            return rules.clone()
        }
        
        let rules = GitignoreRules::load_from_directory(dir.clone())
            .unwrap_or_else(|_| GitignoreRules::new())
        
        self.cache.insert(dir, rules.clone())
        rules
    }
}

