// Greybox Shooter - A simple 3D FPS game in Windjammer
// Demonstrates 3D rendering, physics, input, and game logic

// ============================================================================
// GAME STATE
// ============================================================================

@game
struct ShooterGame {
    // Player state
    player_pos: Vec3,
    player_velocity: Vec3,
    player_yaw: f32,
    player_pitch: f32,
    player_health: int,
    player_on_ground: bool,
    
    // Movement
    move_speed: f32,
    sprint_speed: f32,
    jump_velocity: f32,
    gravity: f32,
    mouse_sensitivity: f32,
    
    // Combat
    weapon: int,  // 0=pistol, 1=shotgun, 2=rocket
    ammo: int,
    score: int,
    
    // Enemies
    enemies: Vec<Enemy>,
    
    // Projectiles
    bullets: Vec<Bullet>,
    
    // Level
    walls: Vec<Wall>,
    floor_y: f32,
    
    // Game state
    paused: bool,
}

struct Enemy {
    pos: Vec3,
    velocity: Vec3,
    health: int,
    state: int,  // 0=idle, 1=chase, 2=attack, 3=dead
    color: Color,
}

struct Bullet {
    pos: Vec3,
    velocity: Vec3,
    damage: int,
    lifetime: f32,
}

struct Wall {
    pos: Vec3,
    size: Vec3,
    color: Color,
}

// ============================================================================
// INITIALIZATION
// ============================================================================

@init
fn init(game: ShooterGame) {
    // Player setup
    game.player_pos = Vec3::new(0.0, 2.0, 0.0)
    game.player_velocity = Vec3::new(0.0, 0.0, 0.0)
    game.player_yaw = 0.0
    game.player_pitch = 0.0
    game.player_health = 100
    game.player_on_ground = true
    
    // Movement constants
    game.move_speed = 5.0
    game.sprint_speed = 10.0
    game.jump_velocity = 8.0
    game.gravity = -20.0
    game.mouse_sensitivity = 0.1
    
    // Combat
    game.weapon = 0
    game.ammo = 100
    game.score = 0
    
    // Level setup
    game.floor_y = 0.0
    game.paused = false
    
    // Create level geometry
    game.create_level()
    
    // Spawn enemies
    game.spawn_enemies()
    
    println("=== GREYBOX SHOOTER ===")
    println("WASD - Move")
    println("Space - Jump")
    println("Shift - Sprint")
    println("Mouse - Look")
    println("Left Click - Shoot")
    println("1/2/3 - Switch weapon")
    println("ESC - Pause")
    println("")
    println("Kill all enemies to win!")
}

impl ShooterGame {
    fn create_level(self) {
        // Create a simple maze-like level with walls
        
        // Outer walls
        self.walls.push(Wall {
            pos: Vec3::new(0.0, 2.0, -20.0),
            size: Vec3::new(40.0, 4.0, 1.0),
            color: Color::rgb(0.5, 0.5, 0.5),
        })
        self.walls.push(Wall {
            pos: Vec3::new(0.0, 2.0, 20.0),
            size: Vec3::new(40.0, 4.0, 1.0),
            color: Color::rgb(0.5, 0.5, 0.5),
        })
        self.walls.push(Wall {
            pos: Vec3::new(-20.0, 2.0, 0.0),
            size: Vec3::new(1.0, 4.0, 40.0),
            color: Color::rgb(0.5, 0.5, 0.5),
        })
        self.walls.push(Wall {
            pos: Vec3::new(20.0, 2.0, 0.0),
            size: Vec3::new(1.0, 4.0, 40.0),
            color: Color::rgb(0.5, 0.5, 0.5),
        })
        
        // Inner walls (maze structure)
        self.walls.push(Wall {
            pos: Vec3::new(-10.0, 2.0, 0.0),
            size: Vec3::new(1.0, 4.0, 15.0),
            color: Color::rgb(0.4, 0.4, 0.4),
        })
        self.walls.push(Wall {
            pos: Vec3::new(10.0, 2.0, 5.0),
            size: Vec3::new(1.0, 4.0, 20.0),
            color: Color::rgb(0.4, 0.4, 0.4),
        })
        self.walls.push(Wall {
            pos: Vec3::new(0.0, 2.0, -10.0),
            size: Vec3::new(15.0, 4.0, 1.0),
            color: Color::rgb(0.4, 0.4, 0.4),
        })
        self.walls.push(Wall {
            pos: Vec3::new(5.0, 2.0, 10.0),
            size: Vec3::new(20.0, 4.0, 1.0),
            color: Color::rgb(0.4, 0.4, 0.4),
        })
    }

    fn spawn_enemies(self) {
        // Spawn 5 enemies at different positions
        self.enemies.push(Enemy {
            pos: Vec3::new(10.0, 1.0, 10.0),
            velocity: Vec3::new(0.0, 0.0, 0.0),
            health: 3,
            state: 1,  // chase
            color: Color::rgb(1.0, 0.0, 0.0),
        })
        self.enemies.push(Enemy {
            pos: Vec3::new(-10.0, 1.0, 10.0),
            velocity: Vec3::new(0.0, 0.0, 0.0),
            health: 3,
            state: 1,
            color: Color::rgb(1.0, 0.2, 0.0),
        })
        self.enemies.push(Enemy {
            pos: Vec3::new(10.0, 1.0, -10.0),
            velocity: Vec3::new(0.0, 0.0, 0.0),
            health: 3,
            state: 1,
            color: Color::rgb(0.8, 0.0, 0.0),
        })
        self.enemies.push(Enemy {
            pos: Vec3::new(-10.0, 1.0, -10.0),
            velocity: Vec3::new(0.0, 0.0, 0.0),
            health: 3,
            state: 1,
            color: Color::rgb(1.0, 0.1, 0.1),
        })
        self.enemies.push(Enemy {
            pos: Vec3::new(0.0, 1.0, 15.0),
            velocity: Vec3::new(0.0, 0.0, 0.0),
            health: 3,
            state: 1,
            color: Color::rgb(0.9, 0.0, 0.0),
        })
    }

    fn update_player_movement(self, delta: f32, input: Input) {
        // Calculate forward and right vectors from yaw
        let yaw_rad = self.player_yaw * 3.14159 / 180.0
        let forward_x = yaw_rad.sin()
        let forward_z = yaw_rad.cos()
        let right_x = (yaw_rad + 1.5708).sin()  // yaw + 90 degrees
        let right_z = (yaw_rad + 1.5708).cos()
        
        // Movement input
        let mut move_x = 0.0
        let mut move_z = 0.0
        
        if input.held(Key::W) {
            move_x += forward_x
            move_z += forward_z
        }
        if input.held(Key::S) {
            move_x -= forward_x
            move_z -= forward_z
        }
        if input.held(Key::A) {
            move_x -= right_x
            move_z -= right_z
        }
        if input.held(Key::D) {
            move_x += right_x
            move_z += right_z
        }
        
        // Normalize movement
        let move_length = (move_x * move_x + move_z * move_z).sqrt()
        if move_length > 0.0 {
            move_x = move_x / move_length
            move_z = move_z / move_length
        }
        
        // Apply speed (sprint if shift is held)
        let speed = if input.held(Key::Shift) {
            self.sprint_speed
        } else {
            self.move_speed
        }
        
        self.player_velocity.x = move_x * speed
        self.player_velocity.z = move_z * speed
        
        // Jump
        if input.pressed(Key::Space) && self.player_on_ground {
            self.player_velocity.y = self.jump_velocity
            self.player_on_ground = false
        }
        
        // Apply gravity
        if !self.player_on_ground {
            self.player_velocity.y += self.gravity * delta
        }
        
        // Update position
        let new_x = self.player_pos.x + self.player_velocity.x * delta
        let new_y = self.player_pos.y + self.player_velocity.y * delta
        let new_z = self.player_pos.z + self.player_velocity.z * delta
        
        // Simple collision detection with walls
        let mut can_move_x = true
        let mut can_move_z = true
        
        for wall in self.walls {
            if check_collision(new_x, self.player_pos.z, wall) {
                can_move_x = false
            }
            if check_collision(self.player_pos.x, new_z, wall) {
                can_move_z = false
            }
        }
        
        if can_move_x {
            self.player_pos.x = new_x
        }
        if can_move_z {
            self.player_pos.z = new_z
        }
        
        // Ground collision
        if new_y <= 2.0 {
            self.player_pos.y = 2.0
            self.player_velocity.y = 0.0
            self.player_on_ground = true
        } else {
            self.player_pos.y = new_y
        }
    }

    fn update_enemies(self, delta: f32) {
        let mut i = 0
        while i < self.enemies.len() {
            let enemy = self.enemies[i]
            
            if enemy.state == 3 {
                // Dead, remove
                self.enemies.remove(i)
                continue
            }
            
            if enemy.state == 1 {
                // Chase player
                let dx = self.player_pos.x - enemy.pos.x
                let dz = self.player_pos.z - enemy.pos.z
                let dist = (dx * dx + dz * dz).sqrt()
                
                if dist > 0.1 {
                    let speed = 2.0
                    enemy.velocity.x = (dx / dist) * speed
                    enemy.velocity.z = (dz / dist) * speed
                    
                    enemy.pos.x += enemy.velocity.x * delta
                    enemy.pos.z += enemy.velocity.z * delta
                }
                
                // Attack if close
                if dist < 2.0 {
                    enemy.state = 2
                }
            }
            
            if enemy.state == 2 {
                // Attack player
                let dx = self.player_pos.x - enemy.pos.x
                let dz = self.player_pos.z - enemy.pos.z
                let dist = (dx * dx + dz * dz).sqrt()
                
                if dist > 3.0 {
                    enemy.state = 1  // Go back to chase
                }
                
                // TODO: Actually damage player
            }
            
            i += 1
        }
    }

    fn update_bullets(self, delta: f32) {
        let mut i = 0
        while i < self.bullets.len() {
            let bullet = self.bullets[i]
            
            // Update position
            bullet.pos.x += bullet.velocity.x * delta
            bullet.pos.y += bullet.velocity.y * delta
            bullet.pos.z += bullet.velocity.z * delta
            
            // Update lifetime
            bullet.lifetime -= delta
            
            // Remove if expired
            if bullet.lifetime <= 0.0 {
                self.bullets.remove(i)
                continue
            }
            
            // Check collision with walls
            let mut hit_wall = false
            for wall in self.walls {
                if check_collision(bullet.pos.x, bullet.pos.z, wall) {
                    hit_wall = true
                    break
                }
            }
            
            if hit_wall {
                self.bullets.remove(i)
                continue
            }
            
            // Check collision with enemies
            let mut hit_enemy = false
            let mut j = 0
            while j < self.enemies.len() {
                let enemy = self.enemies[j]
                let dx = bullet.pos.x - enemy.pos.x
                let dy = bullet.pos.y - enemy.pos.y
                let dz = bullet.pos.z - enemy.pos.z
                let dist = (dx * dx + dy * dy + dz * dz).sqrt()
                
                if dist < 1.0 {
                    // Hit!
                    enemy.health -= bullet.damage
                    if enemy.health <= 0 {
                        enemy.state = 3  // Dead
                        self.score += 100
                        println("Enemy killed! Score: " + self.score.to_string())
                    }
                    hit_enemy = true
                    break
                }
                
                j += 1
            }
            
            if hit_enemy {
                self.bullets.remove(i)
                continue
            }
            
            i += 1
        }
    }

    fn shoot(self) {
        // Calculate bullet direction from player yaw and pitch
        let yaw_rad = self.player_yaw * 3.14159 / 180.0
        let pitch_rad = self.player_pitch * 3.14159 / 180.0
        
        let forward_x = yaw_rad.sin() * pitch_rad.cos()
        let forward_y = pitch_rad.sin()
        let forward_z = yaw_rad.cos() * pitch_rad.cos()
        
        // Bullet speed depends on weapon
        let speed = if self.weapon == 0 {
            30.0  // Pistol
        } else if self.weapon == 1 {
            25.0  // Shotgun
        } else {
            20.0  // Rocket
        }
        
        // Bullet damage depends on weapon
        let damage = if self.weapon == 0 {
            1  // Pistol
        } else if self.weapon == 1 {
            2  // Shotgun
        } else {
            3  // Rocket
        }
        
        // Spawn bullet slightly in front of player
        let spawn_offset = 1.5
        let bullet_pos = Vec3::new(
            self.player_pos.x + forward_x * spawn_offset,
            self.player_pos.y + forward_y * spawn_offset,
            self.player_pos.z + forward_z * spawn_offset
        )
        
        self.bullets.push(Bullet {
            pos: bullet_pos,
            velocity: Vec3::new(forward_x * speed, forward_y * speed, forward_z * speed),
            damage: damage,
            lifetime: 5.0,
        })
        
        println("BANG! Fired weapon " + self.weapon.to_string())
    }
}

// ============================================================================
// INPUT HANDLING
// ============================================================================

@input
fn handle_input(game: ShooterGame, input: Input) {
    if game.paused {
        if input.pressed(Key::Escape) {
            game.paused = false
            println("Game resumed!")
        }
        return
    }
    
    // Pause
    if input.pressed(Key::Escape) {
        game.paused = true
        println("Game paused! Press ESC to resume")
        return
    }
    
    // Shooting
    if input.mouse_pressed(MouseButton::Left) {
        game.shoot()
    }
    
    // Weapon switching
    if input.pressed(Key::Num1) {
        game.weapon = 0
        println("Switched to Pistol")
    }
    if input.pressed(Key::Num2) {
        game.weapon = 1
        println("Switched to Shotgun")
    }
    if input.pressed(Key::Num3) {
        game.weapon = 2
        println("Switched to Rocket Launcher")
    }
}

// ============================================================================
// GAME LOGIC
// ============================================================================

@update
fn update(game: ShooterGame, delta: f32, input: Input) {
    if game.paused {
        return
    }
    
    // Mouse look (camera rotation)
    let dx = input.mouse_delta_x() as f32
    let dy = input.mouse_delta_y() as f32
    
    game.player_yaw += dx * game.mouse_sensitivity
    game.player_pitch -= dy * game.mouse_sensitivity
    
    // Clamp pitch to prevent camera flipping
    if game.player_pitch > 89.0 {
        game.player_pitch = 89.0
    }
    if game.player_pitch < -89.0 {
        game.player_pitch = -89.0
    }
    
    // Player movement
    game.update_player_movement(delta, input)
    
    // Enemy AI
    game.update_enemies(delta)
    
    // Projectiles
    game.update_bullets(delta)
    
    // Check win condition
    if game.enemies.len() == 0 {
        println("YOU WIN! Score: " + game.score.to_string())
        println("Press ESC to exit")
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

fn check_collision(x: f32, z: f32, wall: Wall) -> bool {
    let half_width = wall.size.x / 2.0
    let half_depth = wall.size.z / 2.0
    let player_radius = 0.5
    
    let dx = (x - wall.pos.x).abs()
    let dz = (z - wall.pos.z).abs()
    
    return dx < half_width + player_radius && dz < half_depth + player_radius
}

// ============================================================================
// RENDERING
// ============================================================================

@render3d
fn render(game: ShooterGame, renderer: Renderer3D, camera: Camera3D) {
    // Set up camera from player position and rotation
    camera.position = game.player_pos
    camera.yaw = game.player_yaw
    camera.pitch = game.player_pitch
    
    // Clear screen
    renderer.clear(Color::rgb(0.1, 0.1, 0.15))
    
    // Draw floor
    renderer.draw_plane(
        Vec3::new(0.0, game.floor_y, 0.0),
        Vec3::new(100.0, 0.0, 100.0),
        Color::rgb(0.2, 0.2, 0.2)
    )
    
    // Draw walls
    for wall in game.walls {
        renderer.draw_cube(wall.pos, wall.size, wall.color)
    }
    
    // Draw enemies
    for enemy in game.enemies {
        if enemy.state != 3 {
            renderer.draw_cube(
                enemy.pos,
                Vec3::new(1.0, 2.0, 1.0),
                enemy.color
            )
        }
    }
    
    // Draw bullets
    for bullet in game.bullets {
        renderer.draw_cube(
            bullet.pos,
            Vec3::new(0.2, 0.2, 0.2),
            Color::rgb(1.0, 1.0, 0.0)
        )
    }
    
    // TODO: Draw UI (health, ammo, weapon, score)
}

// ============================================================================
// CLEANUP
// ============================================================================

@cleanup
fn cleanup(game: ShooterGame) {
    println("Final Score: " + game.score.to_string())
    println("Thanks for playing!")
}

// ============================================================================
// MAIN
// ============================================================================

fn main() {
    run_game()
}

