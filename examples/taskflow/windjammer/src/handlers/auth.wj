// Authentication handlers

use std.http
use std.json
use std.crypto
use std.time
use std.db
use std.log

use ../models.user

@derive(Debug, Serialize, Deserialize)
pub struct LoginRequest {
    pub email: string,
    pub password: string,
}

@derive(Debug, Serialize, Deserialize)
pub struct LoginResponse {
    pub token: string,
    pub user: UserResponse,
}

@derive(Debug, Serialize, Deserialize)
pub struct RegisterRequest {
    pub username: string,
    pub email: string,
    pub password: string,
}

@async
pub fn register(req: Request, pool: DbPool) -> Response {
    // Parse request body
    let body = http.body(req)
    let register_req = match json.parse_string(body) {
        Ok(r) => r,
        Err(e) => {
            log.error("Failed to parse register request: ${e}")
            return http.json_response(400, "Invalid request body")
        }
    }
    
    // Hash password
    let password_hash = match crypto.hash_password(register_req.password) {
        Ok(h) => h,
        Err(e) => {
            log.error("Failed to hash password: ${e}")
            return http.json_response(500, "Internal server error")
        }
    }
    
    // Insert user into database
    let now = time.now_unix()
    let query = "INSERT INTO users (username, email, password_hash, created_at, updated_at) VALUES ($1, $2, $3, $4, $5) RETURNING id"
    
    let user_id = match db.query_one(pool, query, vec![register_req.username, register_req.email, password_hash, now, now]) {
        Ok(row) => db.get_int(row, "id"),
        Err(e) => {
            log.error("Failed to create user: ${e}")
            return http.json_response(500, "Failed to create user")
        }
    }
    
    // Generate JWT token
    let token = generate_token(user_id)
    
    let response = LoginResponse {
        token: token,
        user: UserResponse {
            id: user_id,
            username: register_req.username,
            email: register_req.email,
            created_at: now,
        },
    }
    
    log.info("User registered successfully: ${user_id}")
    http.json_response(201, response)
}

@async
pub fn login(req: Request, pool: DbPool) -> Response {
    // Parse request body
    let body = http.body(req)
    let login_req = match json.parse_string(body) {
        Ok(r) => r,
        Err(e) => {
            log.error("Failed to parse login request: ${e}")
            return http.json_response(400, "Invalid request body")
        }
    }
    
    // Find user by email
    let query = "SELECT id, username, email, password_hash, created_at FROM users WHERE email = $1"
    let user = match db.query_one(pool, query, vec![login_req.email]) {
        Ok(row) => row,
        Err(_) => {
            return http.json_response(401, "Invalid credentials")
        }
    }
    
    let user_id = db.get_int(user, "id")
    let password_hash = db.get_string(user, "password_hash")
    
    // Verify password
    let valid = match crypto.verify_password(login_req.password, password_hash) {
        Ok(v) => v,
        Err(e) => {
            log.error("Failed to verify password: ${e}")
            return http.json_response(500, "Internal server error")
        }
    }
    
    if !valid {
        return http.json_response(401, "Invalid credentials")
    }
    
    // Generate JWT token
    let token = generate_token(user_id)
    
    let response = LoginResponse {
        token: token,
        user: UserResponse {
            id: user_id,
            username: db.get_string(user, "username"),
            email: db.get_string(user, "email"),
            created_at: db.get_int(user, "created_at"),
        },
    }
    
    log.info("User logged in successfully: ${user_id}")
    http.json_response(200, response)
}

@async
pub fn logout(req: Request) -> Response {
    // In a real app, you'd invalidate the token here
    log.info("User logged out")
    http.json_response(200, "Logged out successfully")
}

@async
pub fn me(req: Request, pool: DbPool) -> Response {
    // Extract user ID from JWT token
    let user_id = match extract_user_id(req) {
        Some(id) => id,
        None => return http.json_response(401, "Unauthorized"),
    }
    
    // Find user
    let query = "SELECT id, username, email, created_at FROM users WHERE id = $1"
    let user = match db.query_one(pool, query, vec![user_id]) {
        Ok(row) => row,
        Err(_) => {
            return http.json_response(404, "User not found")
        }
    }
    
    let response = UserResponse {
        id: db.get_int(user, "id"),
        username: db.get_string(user, "username"),
        email: db.get_string(user, "email"),
        created_at: db.get_int(user, "created_at"),
    }
    
    http.json_response(200, response)
}

// Helper functions
fn generate_token(user_id: int) -> string {
    // Simplified JWT generation
    let payload = "${user_id}"
    crypto.encode_base64(payload)
}

fn extract_user_id(req: Request) -> Option<int> {
    // Simplified JWT extraction from Authorization header
    let auth_header = http.get_header(req, "Authorization")
    
    match auth_header {
        Some(header) => {
            // Extract token and decode
            let token = header  // In real app: strip "Bearer " prefix
            match crypto.decode_base64(token) {
                Ok(payload) => {
                    // Parse user_id from payload
                    Some(1)  // Simplified - would parse actual ID
                },
                Err(_) => None,
            }
        },
        None => None,
    }
}
