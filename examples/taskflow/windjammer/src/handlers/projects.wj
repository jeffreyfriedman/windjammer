// Project management handlers

use std.http
use std.log
use std.db
use ../models.project.{CreateProjectRequest, UpdateProjectRequest, AddMemberRequest}
use ../db.projects
use ../config
use ../auth.jwt

// List projects for authenticated user
pub async fn list(req: Request) -> ServerResponse {
    log.info("GET /api/v1/projects")
    
    // TODO: Extract user ID from JWT token
    // For now, hardcode user_id = 1
    let user_id = 1
    
    let config = config.load_config()
    let conn = match db.connect(&config.database_url).await {
        Ok(c) => c,
        Err(e) => {
            log.error_with("Database connection failed", "error", &e)
            return ServerResponse::internal_error("Database connection failed")
        }
    }
    
    let projects = match projects.list_for_user(conn, user_id).await {
        Ok(p) => p,
        Err(e) => {
            log.error_with("Database query failed", "error", &e)
            return ServerResponse::internal_error("Database error")
        }
    }
    
    let public_projects = projects.iter().map(|p| p.clone().to_public()).collect()
    ServerResponse::json(public_projects)
}

// Create new project
pub async fn create(req: Request) -> ServerResponse {
    log.info("POST /api/v1/projects")
    
    // Parse request body
    let body = match req.body_json::<CreateProjectRequest>().await {
        Ok(data) => data,
        Err(e) => {
            log.warn_with("Invalid request body", "error", &e)
            return ServerResponse::bad_request("Invalid request body")
        }
    }
    
    // Validate
    if body.name.is_empty() {
        return ServerResponse::bad_request("Project name is required")
    }
    
    // TODO: Extract user ID from JWT token
    let owner_id = 1
    
    let config = config.load_config()
    let conn = match db.connect(&config.database_url).await {
        Ok(c) => c,
        Err(e) => {
            log.error_with("Database connection failed", "error", &e)
            return ServerResponse::internal_error("Database connection failed")
        }
    }
    
    let project = match projects.create(conn, body, owner_id).await {
        Ok(p) => p,
        Err(e) => {
            log.error_with("Project creation failed", "error", &e)
            return ServerResponse::internal_error("Failed to create project")
        }
    }
    
    log.info_with("Project created successfully", "project_id", &project.id.to_string())
    ServerResponse::created(project.to_public())
}

// Get project by ID
pub async fn get(req: Request) -> ServerResponse {
    log.info("GET /api/v1/projects/:id")
    
    let project_id = match req.path_param("id") {
        Some(id) => match id.parse::<int>() {
            Ok(parsed_id) => parsed_id,
            Err(_) => return ServerResponse::bad_request("Invalid project ID")
        },
        None => return ServerResponse::bad_request("Missing project ID")
    }
    
    // TODO: Extract user ID from JWT and check access
    let user_id = 1
    
    let config = config.load_config()
    let conn = match db.connect(&config.database_url).await {
        Ok(c) => c,
        Err(e) => {
            log.error_with("Database connection failed", "error", &e)
            return ServerResponse::internal_error("Database connection failed")
        }
    }
    
    // Check access
    let has_access = match projects.user_has_access(conn.clone(), project_id, user_id).await {
        Ok(access) => access,
        Err(e) => {
            log.error_with("Access check failed", "error", &e)
            return ServerResponse::internal_error("Access check failed")
        }
    }
    
    if !has_access {
        return ServerResponse::forbidden("Access denied")
    }
    
    // Get project
    let project = match projects.find_by_id(conn, project_id).await {
        Ok(Some(p)) => p,
        Ok(None) => return ServerResponse::not_found(),
        Err(e) => {
            log.error_with("Database query failed", "error", &e)
            return ServerResponse::internal_error("Database error")
        }
    }
    
    ServerResponse::json(project.to_public())
}

// Update project
pub async fn update(req: Request) -> ServerResponse {
    log.info("PATCH /api/v1/projects/:id")
    
    let project_id = match req.path_param("id") {
        Some(id) => match id.parse::<int>() {
            Ok(parsed_id) => parsed_id,
            Err(_) => return ServerResponse::bad_request("Invalid project ID")
        },
        None => return ServerResponse::bad_request("Missing project ID")
    }
    
    let body = match req.body_json::<UpdateProjectRequest>().await {
        Ok(data) => data,
        Err(e) => {
            log.warn_with("Invalid request body", "error", &e)
            return ServerResponse::bad_request("Invalid request body")
        }
    }
    
    // TODO: Extract user ID from JWT and check if owner
    let user_id = 1
    
    let config = config.load_config()
    let conn = match db.connect(&config.database_url).await {
        Ok(c) => c,
        Err(e) => {
            log.error_with("Database connection failed", "error", &e)
            return ServerResponse::internal_error("Database connection failed")
        }
    }
    
    // Check if user is owner
    let is_owner = match projects.is_owner(conn.clone(), project_id, user_id).await {
        Ok(owner) => owner,
        Err(e) => {
            log.error_with("Owner check failed", "error", &e)
            return ServerResponse::internal_error("Owner check failed")
        }
    }
    
    if !is_owner {
        return ServerResponse::forbidden("Only project owner can update")
    }
    
    let project = match projects.update(conn, project_id, body.name, body.description).await {
        Ok(p) => p,
        Err(e) => {
            log.error_with("Project update failed", "error", &e)
            return ServerResponse::internal_error("Failed to update project")
        }
    }
    
    ServerResponse::json(project.to_public())
}

// Delete project
pub async fn delete(req: Request) -> ServerResponse {
    log.info("DELETE /api/v1/projects/:id")
    
    let project_id = match req.path_param("id") {
        Some(id) => match id.parse::<int>() {
            Ok(parsed_id) => parsed_id,
            Err(_) => return ServerResponse::bad_request("Invalid project ID")
        },
        None => return ServerResponse::bad_request("Missing project ID")
    }
    
    // TODO: Extract user ID from JWT and check if owner
    let user_id = 1
    
    let config = config.load_config()
    let conn = match db.connect(&config.database_url).await {
        Ok(c) => c,
        Err(e) => {
            log.error_with("Database connection failed", "error", &e)
            return ServerResponse::internal_error("Database connection failed")
        }
    }
    
    // Check if user is owner
    let is_owner = match projects.is_owner(conn.clone(), project_id, user_id).await {
        Ok(owner) => owner,
        Err(e) => {
            log.error_with("Owner check failed", "error", &e)
            return ServerResponse::internal_error("Owner check failed")
        }
    }
    
    if !is_owner {
        return ServerResponse::forbidden("Only project owner can delete")
    }
    
    match projects.delete(conn, project_id).await {
        Ok(_) => {},
        Err(e) => {
            log.error_with("Project deletion failed", "error", &e)
            return ServerResponse::internal_error("Failed to delete project")
        }
    }
    
    ServerResponse::no_content()
}

// Add member to project
pub async fn add_member(req: Request) -> ServerResponse {
    log.info("POST /api/v1/projects/:id/members")
    
    let project_id = match req.path_param("id") {
        Some(id) => match id.parse::<int>() {
            Ok(parsed_id) => parsed_id,
            Err(_) => return ServerResponse::bad_request("Invalid project ID")
        },
        None => return ServerResponse::bad_request("Missing project ID")
    }
    
    let body = match req.body_json::<AddMemberRequest>().await {
        Ok(data) => data,
        Err(e) => {
            log.warn_with("Invalid request body", "error", &e)
            return ServerResponse::bad_request("Invalid request body")
        }
    }
    
    // TODO: Extract user ID from JWT and check if owner
    let owner_id = 1
    
    let config = config.load_config()
    let conn = match db.connect(&config.database_url).await {
        Ok(c) => c,
        Err(e) => {
            log.error_with("Database connection failed", "error", &e)
            return ServerResponse::internal_error("Database connection failed")
        }
    }
    
    // Check if user is owner
    let is_owner = match projects.is_owner(conn.clone(), project_id, owner_id).await {
        Ok(owner) => owner,
        Err(e) => {
            log.error_with("Owner check failed", "error", &e)
            return ServerResponse::internal_error("Owner check failed")
        }
    }
    
    if !is_owner {
        return ServerResponse::forbidden("Only project owner can add members")
    }
    
    let member = match projects.add_member(conn, project_id, body.user_id, body.role).await {
        Ok(m) => m,
        Err(e) => {
            log.error_with("Add member failed", "error", &e)
            return ServerResponse::internal_error("Failed to add member")
        }
    }
    
    ServerResponse::created(member)
}

// Remove member from project
pub async fn remove_member(req: Request) -> ServerResponse {
    log.info("DELETE /api/v1/projects/:id/members/:user_id")
    
    let project_id = match req.path_param("id") {
        Some(id) => match id.parse::<int>() {
            Ok(parsed_id) => parsed_id,
            Err(_) => return ServerResponse::bad_request("Invalid project ID")
        },
        None => return ServerResponse::bad_request("Missing project ID")
    }
    
    let member_user_id = match req.path_param("user_id") {
        Some(id) => match id.parse::<int>() {
            Ok(parsed_id) => parsed_id,
            Err(_) => return ServerResponse::bad_request("Invalid user ID")
        },
        None => return ServerResponse::bad_request("Missing user ID")
    }
    
    // TODO: Extract user ID from JWT and check if owner
    let owner_id = 1
    
    let config = config.load_config()
    let conn = match db.connect(&config.database_url).await {
        Ok(c) => c,
        Err(e) => {
            log.error_with("Database connection failed", "error", &e)
            return ServerResponse::internal_error("Database connection failed")
        }
    }
    
    // Check if user is owner
    let is_owner = match projects.is_owner(conn.clone(), project_id, owner_id).await {
        Ok(owner) => owner,
        Err(e) => {
            log.error_with("Owner check failed", "error", &e)
            return ServerResponse::internal_error("Owner check failed")
        }
    }
    
    if !is_owner {
        return ServerResponse::forbidden("Only project owner can remove members")
    }
    
    match projects.remove_member(conn, project_id, member_user_id).await {
        Ok(_) => {},
        Err(e) => {
            log.error_with("Remove member failed", "error", &e)
            return ServerResponse::internal_error("Failed to remove member")
        }
    }
    
    ServerResponse::no_content()
}
