// WebAssembly Game Example - Conway's Game of Life
// No imports needed! @export automatically handles everything

const WIDTH: u32 = 64
const HEIGHT: u32 = 64

@export
struct Universe {
    width: u32,
    height: u32,
    cells: Vec<bool>,
}

@export
impl Universe {
    fn new() -> Universe {
        let width = WIDTH
        let height = HEIGHT
        
        let cells = (0..width * height)
            .map(|i| i % 2 == 0 || i % 7 == 0)
            .collect()
        
        Universe {
            width,
            height,
            cells,
        }
    }
    
    fn width(&self) -> u32 {
        self.width
    }
    
    fn height(&self) -> u32 {
        self.height
    }
    
    fn get_cell(&self, row: u32, col: u32) -> bool {
        let idx = self.get_index(row, col)
        self.cells[idx]
    }
    
    @timing
    fn tick(&mut self) {
        let mut next = self.cells.clone()
        
        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col)
                let cell = self.cells[idx]
                let live_neighbors = self.live_neighbor_count(row, col)
                
                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than 2 live neighbors dies
                    (true, x) if x < 2 => false,
                    // Rule 2: Any live cell with 2 or 3 live neighbors lives
                    (true, 2) | (true, 3) => true,
                    // Rule 3: Any live cell with more than 3 live neighbors dies
                    (true, x) if x > 3 => false,
                    // Rule 4: Any dead cell with exactly 3 live neighbors becomes alive
                    (false, 3) => true,
                    // All other cells remain in the same state
                    (otherwise, _) => otherwise,
                }
                
                next[idx] = next_cell
            }
        }
        
        self.cells = next
    }
    
    fn toggle_cell(&mut self, row: u32, col: u32) {
        let idx = self.get_index(row, col)
        self.cells[idx] = !self.cells[idx]
    }
    
    fn reset(&mut self) {
        self.cells = (0..self.width * self.height)
            .map(|_| false)
            .collect()
    }
    
    fn randomize(&mut self) {
        // Use a simple deterministic pattern for now
        self.cells = (0..self.width * self.height)
            .map(|i| i % 2 == 0 || i % 7 == 0)
            .collect()
    }
}

impl Universe {
    fn get_index(&self, row: u32, col: u32) -> usize {
        (row * self.width + col) as usize
    }
    
    fn live_neighbor_count(&self, row: u32, col: u32) -> u32 {
        let mut count = 0
        
        for delta_row in 0..3 {
            for delta_col in 0..3 {
                if delta_row == 1 && delta_col == 1 {
                    continue
                }
                
                let neighbor_row = ((row + delta_row + self.height - 1) % self.height)
                let neighbor_col = ((col + delta_col + self.width - 1) % self.width)
                let idx = self.get_index(neighbor_row, neighbor_col)
                
                if self.cells[idx] {
                    count += 1
                }
            }
        }
        
        count
    }
}

// Render function for canvas
@export
fn render(universe: &Universe, ctx: &web_sys.CanvasRenderingContext2d, cell_size: u32) {
    let alive_color = "black"
    let dead_color = "white"
    
    ctx.begin_path()
    
    for row in 0..universe.height {
        for col in 0..universe.width {
            let idx = universe.get_index(row, col)
            
            let color = if universe.cells[idx] {
                alive_color.into()
            } else {
                dead_color.into()
            }
            ctx.set_fill_style(&color)
            
            ctx.fill_rect(
                (col * cell_size) as f64,
                (row * cell_size) as f64,
                cell_size as f64,
                cell_size as f64,
            )
        }
    }
    
    // Draw grid lines
    let grid_color = "#CCCCCC".into()
    ctx.set_stroke_style(&grid_color)
    ctx.begin_path()
    
    // Vertical lines
    for i in 0..=universe.width {
        let x = (i * cell_size) as f64
        ctx.move_to(x, 0.0)
        ctx.line_to(x, (universe.height * cell_size) as f64)
    }
    
    // Horizontal lines
    for i in 0..=universe.height {
        let y = (i * cell_size) as f64
        ctx.move_to(0.0, y)
        ctx.line_to((universe.width * cell_size) as f64, y)
    }
    
    ctx.stroke()
}

// Performance statistics
@export
struct Stats {
    generation: u32,
    fps: f64,
    alive_cells: u32,
}

@export
impl Stats {
    fn new() -> Stats {
        Stats {
            generation: 0,
            fps: 0.0,
            alive_cells: 0,
        }
    }
    
    fn update(&mut self, universe: &Universe, delta_time: f64) {
        self.generation += 1
        self.fps = 1000.0 / delta_time
        self.alive_cells = universe.cells.iter().filter(|c| **c).count() as u32
    }
    
    fn generation(&self) -> u32 {
        self.generation
    }
    
    fn fps(&self) -> f64 {
        self.fps
    }
    
    fn alive_cells(&self) -> u32 {
        self.alive_cells
    }
}

