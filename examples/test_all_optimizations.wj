// Comprehensive test demonstrating all 10 compiler optimization phases
// This example showcases how Windjammer automatically optimizes naive code

// Phase 7: Const/Static Optimization
// These statics will be promoted to const at compile time
static MAX_USERS: int = 1000
static CACHE_SIZE: int = MAX_USERS * 2
static DEFAULT_TIMEOUT: float = 30.0

// Phase 8: SmallVec - Stack allocation for small vectors
fn get_fibonacci_sequence(count: int) -> vec<int> {
    // Small vector literals become SmallVec (stack allocated)
    if count <= 3 {
        vec![1, 1, 2]  // Phase 8: SmallVec<[i32; 4]>
    } else {
        vec![1, 1, 2, 3, 5, 8]  // Phase 8: SmallVec<[i32; 8]>
    }
}

// Phase 9: Cow - Clone-on-write for conditional modification
fn format_username(name: string, capitalize: bool) -> string {
    // Parameter becomes Cow<'_, str> automatically
    if capitalize {
        name.to_uppercase()  // Cow::Owned (only when modified)
    } else {
        name  // Cow::Borrowed (zero-cost!)
    }
}

// Phase 2: Clone elimination
fn process_data(numbers: vec<int>) -> int {
    // Compiler infers ownership - no manual .clone() needed
    let sum = numbers.iter().sum()
    sum
}

// Phase 4: String capacity optimization
fn build_message(user: string, action: string) -> string {
    // Compiler pre-allocates buffer with correct capacity
    let mut msg = "User: "
    msg.push_str(user)
    msg.push_str(" performed: ")
    msg.push_str(action)
    msg
}

// Phase 0: Defer drop - Automatically defers heavy deallocations
fn get_user_count(cache: HashMap<string, vec<int>>) -> int {
    // Function returns instantly, cache dropped in background thread
    cache.len()  // 393x faster return!
}

// Phase 1: Inline hints - Hot path gets automatic #[inline]
fn is_valid_user_id(id: int) -> bool {
    // Simple function, automatically inlined
    id > 0 && id <= MAX_USERS
}

// Phase 5: Compound assignments
fn increment_counter(count: int) -> int {
    let mut result = count
    result = result + 1  // Optimized to result += 1
    result
}

// Phase 6: Constant folding
fn calculate_buffer_size() -> int {
    // Computed at compile time
    MAX_USERS * 4 + 128
}

fn main() {
    println!("=== Windjammer Compiler Optimization Demo ===")
    println!("")
    
    // Test Phase 7: Const/Static
    println!("Phase 7 - Const/Static:")
    println!("  MAX_USERS = {}", MAX_USERS)
    println!("  CACHE_SIZE = {}", CACHE_SIZE)
    println!("")
    
    // Test Phase 8: SmallVec
    println!("Phase 8 - SmallVec:")
    let fib = get_fibonacci_sequence(3)
    println!("  Fibonacci (stack allocated): {:?}", fib)
    println!("")
    
    // Test Phase 9: Cow
    println!("Phase 9 - Cow (Clone-on-Write):")
    let name1 = format_username("alice", false)
    let name2 = format_username("bob", true)
    println!("  Normal: {}", name1)
    println!("  Uppercase: {}", name2)
    println!("")
    
    // Test Phase 2: Clone elimination
    println!("Phase 2 - Clone Elimination:")
    let nums = vec![1, 2, 3, 4, 5]
    let total = process_data(nums)
    println!("  Sum: {}", total)
    println!("")
    
    // Test Phase 4: String capacity
    println!("Phase 4 - String Capacity:")
    let msg = build_message("Alice", "login")
    println!("  Message: {}", msg)
    println!("")
    
    // Test Phase 1: Inline hints
    println!("Phase 1 - Inline Hints:")
    println!("  Is valid(500)? {}", is_valid_user_id(500))
    println!("  Is valid(-1)? {}", is_valid_user_id(-1))
    println!("")
    
    // Test Phase 5: Compound assignments
    println!("Phase 5 - Compound Assignments:")
    println!("  Increment 41: {}", increment_counter(41))
    println!("")
    
    // Test Phase 6: Constant folding
    println!("Phase 6 - Constant Folding:")
    println!("  Buffer size: {}", calculate_buffer_size())
    println!("")
    
    println!("All optimizations applied automatically! ðŸš€")
}

