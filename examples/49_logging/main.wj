// Example 49: Logging
// Demonstrates Windjammer's std.log module

use std.log

fn process_request(user_id: int, action: string) {
    log.info_with("Processing request", "user_id", user_id.to_string())
    log.debug_with("Action details", "action", action)
    
    // Simulate some processing
    if action == "dangerous" {
        log.warn_with("Potentially dangerous action", "action", action)
    }
}

fn connect_to_database() -> Result<(), Error> {
    log.info("Connecting to database...")
    
    // Simulate connection
    let success = true
    
    if success {
        log.info("Database connection established")
        Ok(())
    } else {
        log.error("Failed to connect to database")
        Err("Connection failed")
    }
}

fn expensive_debug_calculation() -> string {
    // Simulate expensive operation
    log.trace("Running expensive debug calculation")
    "Debug data: [complex information]".to_string()
}

fn main() {
    println!("=== Logging Demo ===")
    println!()
    
    // Initialize logger
    // In real usage, set RUST_LOG environment variable:
    // RUST_LOG=trace cargo run    - Show everything
    // RUST_LOG=debug cargo run    - Show debug and above
    // RUST_LOG=info cargo run     - Show info and above (default)
    // RUST_LOG=warn cargo run     - Show warnings and errors only
    
    println!("Initializing logger with 'debug' level...")
    log.init_with_level("debug")
    println!()
    
    // Different log levels
    println!("1. Log Levels:")
    log.trace("This is a TRACE message (very detailed)")
    log.debug("This is a DEBUG message (debugging info)")
    log.info("This is an INFO message (general information)")
    log.warn("This is a WARN message (warning)")
    log.error("This is an ERROR message (error)")
    println!()
    
    // Structured logging with context
    println!("2. Structured Logging (with context):")
    log.info_with("Server started", "port", "3000")
    log.info_with("Configuration loaded", "env", "development")
    log.warn_with("Memory usage high", "usage_mb", "850")
    log.error_with("Request timeout", "endpoint", "/api/users")
    println!()
    
    // Real-world usage patterns
    println!("3. Real-World Patterns:")
    
    // Logging in functions
    process_request(12345, "read")
    process_request(67890, "dangerous")
    println!()
    
    // Error handling with logging
    match connect_to_database() {
        Ok(_) => log.info("Application ready"),
        Err(e) => log.error(&format!("Startup failed: {}", e))
    }
    println!()
    
    // Conditional logging for expensive operations
    println!("4. Conditional Logging:")
    if log.debug_enabled() {
        let debug_info = expensive_debug_calculation()
        log.debug(&debug_info)
        println!("   (Debug logging is enabled)")
    } else {
        println!("   (Debug logging is disabled - skipping expensive calculation)")
    }
    println!()
    
    // Check what levels are enabled
    println!("5. Log Level Status:")
    println!("   Trace enabled: {}", log.trace_enabled())
    println!("   Debug enabled: {}", log.debug_enabled())
    println!("   Info enabled: {}", log.info_enabled())
    println!("   Warn enabled: {}", log.warn_enabled())
    println!("   Error enabled: {}", log.error_enabled())
    println!()
    
    println!("✨ Logging with Windjammer!")
    println!("   ✅ Using std.log abstraction (not log:: or env_logger:: directly)")
    println!("   ✅ Clean, Windjammer-native API")
    println!("   ✅ Multiple log levels (trace, debug, info, warn, error)")
    println!("   ✅ Structured logging with key-value pairs")
    println!("   ✅ Conditional logging to avoid expensive operations")
    println!()
    println!("TIP: Set RUST_LOG environment variable to control log level")
    println!("     Example: RUST_LOG=debug cargo run")
}

