//! Code generation for transformed components
#![allow(clippy::single_char_add_str)]

use super::transformer::{TransformedComponent, TransformedMethod};
use anyhow::Result;

/// Generates Rust code for a transformed component
pub struct ComponentCodegen;

impl ComponentCodegen {
    /// Generate Rust code for a component
    pub fn generate(component: &TransformedComponent) -> Result<String> {
        let mut code = String::new();

        // Generate imports
        code.push_str(&Self::generate_imports());
        code.push_str("\n\n");

        // Generate struct
        code.push_str(&Self::generate_struct(component));
        code.push_str("\n\n");

        // Generate impl block
        code.push_str(&Self::generate_impl(component));

        Ok(code)
    }

    fn generate_imports() -> String {
        r#"// Generated by Windjammer UI Component Compiler
use windjammer_ui::prelude::*;
use windjammer_ui::reactivity::{Signal, Effect};
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;
use web_sys::{Document, Element, HtmlElement, Window, Event};
use std::rc::Rc;
use std::cell::RefCell;"#
            .to_string()
    }

    fn generate_struct(component: &TransformedComponent) -> String {
        let mut code = String::new();
        code.push_str("/// Component struct with reactive state\n");
        code.push_str("#[derive(Clone)]\n");
        code.push_str("#[wasm_bindgen]\n");
        code.push_str(&format!("pub struct {} {{\n", component.name));

        for field in &component.fields {
            code.push_str(&format!("    /// Reactive field: {}\n", field.name));
            code.push_str(&format!("    {}: {},\n", field.name, field.type_));
        }

        code.push('}');
        code
    }

    fn generate_impl(component: &TransformedComponent) -> String {
        let mut code = String::new();
        code.push_str("#[wasm_bindgen]\n");
        code.push_str(&format!("impl {} {{\n", component.name));

        for method in &component.methods {
            code.push_str(&Self::generate_method(method));
            code.push_str("\n");
        }

        code.push_str("}");
        code
    }

    fn generate_method(method: &TransformedMethod) -> String {
        let mut code = String::new();

        // Generate method signature
        code.push_str("    /// ");
        code.push_str(&method.name);
        code.push_str("\n");
        code.push_str("    #[wasm_bindgen]\n");
        code.push_str("    pub fn ");
        code.push_str(&method.name);
        code.push_str("(");

        // Add self parameter for non-constructor methods
        if method.name != "new" {
            code.push_str("&mut self");
            if !method.params.is_empty() {
                code.push_str(", ");
            }
        }

        // Add parameters
        code.push_str(&method.params.join(", "));
        code.push_str(")");

        // Add return type
        if let Some(return_type) = &method.return_type {
            code.push_str(" -> ");
            code.push_str(return_type);
        }

        code.push_str(" {\n");

        // Add method body with proper indentation
        for line in method.body.lines() {
            if !line.is_empty() {
                code.push_str("        ");
                code.push_str(line);
            }
            code.push_str("\n");
        }

        code.push_str("    }\n");
        code
    }

    /// Generate a complete WASM project structure
    pub fn generate_project(component: &TransformedComponent) -> Result<Vec<(String, String)>> {
        let mut files = Vec::new();

        // Generate main component file
        let component_code = Self::generate(component)?;
        files.push(("src/lib.rs".to_string(), component_code));

        // Generate Cargo.toml
        let cargo_toml = Self::generate_cargo_toml(&component.name)?;
        files.push(("Cargo.toml".to_string(), cargo_toml));

        // Generate index.html
        let index_html = Self::generate_index_html(&component.name)?;
        files.push(("index.html".to_string(), index_html));

        // Generate README
        let readme = Self::generate_readme(&component.name)?;
        files.push(("README.md".to_string(), readme));

        Ok(files)
    }

    pub fn generate_cargo_toml(component_name: &str) -> Result<String> {
        Ok(format!(
            r#"[package]
name = "{}"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

# Prevent this from being treated as part of parent workspace
[workspace]

[dependencies]
windjammer-ui = {{ path = "../crates/windjammer-ui", features = ["web"] }}
wasm-bindgen = "0.2"
web-sys = {{ version = "0.3", features = [
    "Document",
    "Element",
    "HtmlElement",
    "Node",
    "Text",
    "Window",
    "Event",
    "MouseEvent",
] }}
js-sys = "0.3"
console_error_panic_hook = "0.1"

[profile.release]
opt-level = "z"
lto = true
"#,
            component_name.to_lowercase()
        ))
    }

    pub fn generate_index_html(component_name: &str) -> Result<String> {
        Ok(format!(
            r#"<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        #app {{
            max-width: 800px;
            margin: 0 auto;
        }}
    </style>
</head>
<body>
    <div id="app"></div>
    <script type="module">
        import init, {{ {} }} from './pkg/{}.js';
        
        async function run() {{
            await init();
            const component = {}.new();
            component.mount();
        }}
        
        run();
    </script>
</body>
</html>
"#,
            component_name,
            component_name,
            component_name.to_lowercase(),
            component_name
        ))
    }

    pub fn generate_readme(component_name: &str) -> Result<String> {
        Ok(format!(
            r#"# {}

A Windjammer UI component compiled to WebAssembly.

## Building

```bash
wasm-pack build --target web
```

## Running

Serve the directory with any HTTP server:

```bash
python3 -m http.server 8080
```

Then open http://localhost:8080 in your browser.

## Development

This component was generated by the Windjammer UI compiler.
Edit the source `.wj` file and recompile to see changes.
"#,
            component_name
        ))
    }
}
