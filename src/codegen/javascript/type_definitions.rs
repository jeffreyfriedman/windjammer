//! TypeScript definition (.d.ts) generation
//!
//! Generates TypeScript type definitions for IDE support and type checking

use crate::parser::*;

/// Generate TypeScript definitions for the program
pub fn generate_type_definitions(program: &Program) -> Option<String> {
    let mut output = String::new();

    output.push_str("// Generated by Windjammer JavaScript transpiler\n");
    output.push_str("// TypeScript definitions\n\n");

    for item in &program.items {
        match item {
            Item::Function { decl: func, .. } => {
                output.push_str(&generate_function_declaration(func));
                output.push('\n');
            }
            Item::Struct {
                decl: struct_def, ..
            } => {
                output.push_str(&generate_interface(struct_def));
                output.push('\n');
            }
            Item::Enum { decl: enum_def, .. } => {
                output.push_str(&generate_enum_declaration(enum_def));
                output.push('\n');
            }
            _ => {}
        }
    }

    if output.len() > 100 {
        Some(output)
    } else {
        None
    }
}

fn generate_function_declaration(func: &FunctionDecl) -> String {
    let mut output = String::new();

    output.push_str("export declare function ");
    output.push_str(&func.name);
    output.push('(');

    let params: Vec<String> = func
        .parameters
        .iter()
        .map(|p| format!("{}: {}", p.name, type_to_ts(&p.type_)))
        .collect();
    output.push_str(&params.join(", "));

    output.push_str("): ");
    if let Some(ref ret_type) = func.return_type {
        output.push_str(&type_to_ts(ret_type));
    } else {
        output.push_str("void");
    }
    output.push_str(";\n");

    output
}

fn generate_interface(struct_def: &StructDecl) -> String {
    let mut output = String::new();

    output.push_str(&format!("export interface {} {{\n", struct_def.name));

    for field in &struct_def.fields {
        output.push_str(&format!(
            "    {}: {};\n",
            field.name,
            type_to_ts(&field.field_type)
        ));
    }

    output.push_str("}\n");

    // Also generate class declaration
    output.push_str(&format!("\nexport declare class {} {{\n", struct_def.name));
    output.push_str("    constructor(");
    let params: Vec<String> = struct_def
        .fields
        .iter()
        .map(|f| format!("{}: {}", f.name, type_to_ts(&f.field_type)))
        .collect();
    output.push_str(&params.join(", "));
    output.push_str(");\n");

    for field in &struct_def.fields {
        output.push_str(&format!(
            "    {}: {};\n",
            field.name,
            type_to_ts(&field.field_type)
        ));
    }

    output.push_str("}\n");

    output
}

fn generate_enum_declaration(enum_def: &EnumDecl) -> String {
    let mut output = String::new();

    output.push_str(&format!("export declare const {}: {{\n", enum_def.name));

    for variant in &enum_def.variants {
        output.push_str(&format!("    readonly {}: symbol;\n", variant.name));
    }

    output.push_str("};\n");

    output
}

fn type_to_ts(ty: &Type) -> String {
    match ty {
        Type::Int | Type::Int32 | Type::Uint | Type::Float => "number".to_string(),
        Type::String => "string".to_string(),
        Type::Bool => "boolean".to_string(),
        Type::Custom(name) => name.clone(),
        Type::Generic(name) => name.clone(),
        Type::Parameterized(name, args) => {
            if args.is_empty() {
                name.clone()
            } else {
                let type_args: Vec<String> = args.iter().map(type_to_ts).collect();
                format!("{}<{}>", name, type_args.join(", "))
            }
        }
        Type::Vec(inner) => format!("Array<{}>", type_to_ts(inner)),
        Type::Option(inner) => format!("{} | null", type_to_ts(inner)),
        Type::Result(ok, _err) => type_to_ts(ok), // Simplified - just return the Ok type
        Type::Reference(inner) | Type::MutableReference(inner) => type_to_ts(inner),
        Type::Tuple(types) => {
            if types.is_empty() {
                "void".to_string()
            } else {
                let type_strs: Vec<String> = types.iter().map(type_to_ts).collect();
                format!("[{}]", type_strs.join(", "))
            }
        }
        _ => "any".to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_function_definition() {
        let func = FunctionDecl {
            name: "greet".to_string(),
            parameters: vec![Parameter {
                name: "name".to_string(),
                pattern: None,
                type_: Type::String,
                ownership: OwnershipHint::Inferred,
            }],
            return_type: None,
            body: vec![],
            decorators: vec![],
            is_pub: false,
            is_async: false,
            type_params: vec![],
            where_clause: vec![],
            parent_type: None,
        };

        let decl = generate_function_declaration(&func);
        assert!(decl.contains("export declare function greet"));
        assert!(decl.contains("name: string"));
        assert!(decl.contains("): void"));
    }

    #[test]
    fn test_generate_interface() {
        let struct_def = StructDecl {
            name: "Point".to_string(),
            is_pub: true, // Test struct is public
            fields: vec![
                StructField {
                    name: "x".to_string(),
                    field_type: Type::Int,
                    is_pub: true,
                    decorators: vec![],
                },
                StructField {
                    name: "y".to_string(),
                    field_type: Type::Int,
                    is_pub: true,
                    decorators: vec![],
                },
            ],
            decorators: vec![],
            type_params: vec![],
            where_clause: vec![],
        };

        let interface = generate_interface(&struct_def);
        assert!(interface.contains("export interface Point"));
        assert!(interface.contains("x: number"));
        assert!(interface.contains("y: number"));
    }
}
