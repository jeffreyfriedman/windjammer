//! JavaScript code generator (ES2020+)
//!
//! Generates clean, idiomatic JavaScript from Windjammer AST

use crate::parser::*;
use std::collections::HashMap;

pub struct JavaScriptGenerator {
    indent_level: usize,
    async_functions: HashMap<String, bool>,
}

impl JavaScriptGenerator {
    pub fn new() -> Self {
        Self {
            indent_level: 0,
            async_functions: HashMap::new(),
        }
    }

    pub fn generate(&mut self, program: &Program) -> String {
        let mut output = String::new();

        // Add file header
        output.push_str("// Generated by Windjammer JavaScript transpiler (v0.32.0)\n");
        output.push_str("// https://windjammer.dev\n\n");

        // First pass: Detect async functions
        self.detect_async_functions(program);

        // Generate each item
        for item in &program.items {
            let code = self.generate_item(item);
            if !code.is_empty() {
                output.push_str(&code);
                output.push_str("\n\n");
            }
        }

        // Add auto-run main if it exists
        if self.has_main_function(program) {
            output.push_str(&self.generate_auto_run_main());
        }

        output
    }

    fn detect_async_functions(&mut self, program: &Program) {
        for item in &program.items {
            if let Item::Function(func) = item {
                let is_async = func.is_async || self.contains_await_in_body(&func.body);
                self.async_functions.insert(func.name.clone(), is_async);
            }
        }
    }

    fn contains_await_in_body(&self, statements: &[Statement]) -> bool {
        statements.iter().any(Self::contains_await_stmt)
    }

    fn contains_await_stmt(stmt: &Statement) -> bool {
        match stmt {
            Statement::Expression(expr) => Self::contains_await_expr(expr),
            Statement::Let { value, .. } => Self::contains_await_expr(value),
            Statement::Return(Some(expr)) => Self::contains_await_expr(expr),
            Statement::If {
                condition,
                then_block,
                else_block,
            } => {
                Self::contains_await_expr(condition)
                    || then_block.iter().any(Self::contains_await_stmt)
                    || else_block
                        .as_ref()
                        .is_some_and(|block| block.iter().any(Self::contains_await_stmt))
            }
            _ => false,
        }
    }

    fn contains_await_expr(expr: &Expression) -> bool {
        match expr {
            Expression::Await(_) => true,
            Expression::Binary { left, right, .. } => {
                Self::contains_await_expr(left) || Self::contains_await_expr(right)
            }
            Expression::Call {
                function,
                arguments,
            } => {
                Self::contains_await_expr(function)
                    || arguments
                        .iter()
                        .any(|(_, arg)| Self::contains_await_expr(arg))
            }
            Expression::MethodCall {
                object, arguments, ..
            } => {
                Self::contains_await_expr(object)
                    || arguments
                        .iter()
                        .any(|(_, arg)| Self::contains_await_expr(arg))
            }
            _ => false,
        }
    }

    fn has_main_function(&self, program: &Program) -> bool {
        program
            .items
            .iter()
            .any(|item| matches!(item, Item::Function(func) if func.name == "main"))
    }

    fn generate_auto_run_main(&self) -> String {
        let is_async = self.async_functions.get("main").copied().unwrap_or(false);

        if is_async {
            r#"// Auto-run main if executed directly (Node.js)
if (import.meta.url === `file://${process.argv[1]}`) {
    main().catch(console.error);
}
"#
            .to_string()
        } else {
            r#"// Auto-run main if executed directly (Node.js)
if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}
"#
            .to_string()
        }
    }

    fn generate_item(&mut self, item: &Item) -> String {
        match item {
            Item::Function(func) => self.generate_function(func),
            Item::Struct(struct_decl) => self.generate_struct(struct_decl),
            Item::Enum(enum_decl) => self.generate_enum(enum_decl),
            Item::Trait(_) => String::from("// Trait (use duck typing in JavaScript)"),
            Item::Impl(_) => String::new(), // Impl blocks are merged into classes
            Item::Use { .. } => String::new(), // Imports handled separately
            Item::Const { name, value, .. } => {
                format!(
                    "export const {} = {};\n",
                    name,
                    self.generate_expression(value)
                )
            }
            Item::Static { name, value, .. } => {
                format!(
                    "export let {} = {};\n",
                    name,
                    self.generate_expression(value)
                )
            }
            _ => "// TODO: Unsupported item type".to_string(),
        }
    }

    fn generate_function(&mut self, func: &FunctionDecl) -> String {
        let mut output = String::new();

        // Generate JSDoc
        if !func.parameters.is_empty() || func.return_type.is_some() {
            output.push_str("/**\n");
            for param in &func.parameters {
                output.push_str(&format!(
                    " * @param {{{}}} {}\n",
                    Self::type_to_jsdoc(&param.type_),
                    param.name
                ));
            }
            if let Some(ref ret_type) = func.return_type {
                output.push_str(&format!(
                    " * @returns {{{}}}\n",
                    Self::type_to_jsdoc(ret_type)
                ));
            }
            output.push_str(" */\n");
        }

        // Function declaration
        output.push_str("export ");

        let is_async = self
            .async_functions
            .get(&func.name)
            .copied()
            .unwrap_or(false);
        if is_async {
            output.push_str("async ");
        }

        output.push_str("function ");
        output.push_str(&func.name);
        output.push('(');

        // Parameters
        let params: Vec<String> = func.parameters.iter().map(|p| p.name.clone()).collect();
        output.push_str(&params.join(", "));
        output.push_str(") {\n");

        // Body
        self.indent_level += 1;
        for stmt in &func.body {
            output.push_str(&self.generate_statement(stmt));
        }
        self.indent_level -= 1;

        output.push('}');
        output
    }

    fn generate_struct(&mut self, struct_decl: &StructDecl) -> String {
        let mut output = String::new();

        output.push_str(&format!("export class {} {{\n", struct_decl.name));
        self.indent_level += 1;

        // Constructor
        output.push_str(&self.indent());
        output.push_str("constructor(");
        let params: Vec<String> = struct_decl.fields.iter().map(|f| f.name.clone()).collect();
        output.push_str(&params.join(", "));
        output.push_str(") {\n");

        self.indent_level += 1;
        for field in &struct_decl.fields {
            output.push_str(&self.indent());
            output.push_str(&format!("this.{} = {};\n", field.name, field.name));
        }
        self.indent_level -= 1;

        output.push_str(&self.indent());
        output.push_str("}\n");

        self.indent_level -= 1;
        output.push('}');
        output
    }

    fn generate_enum(&mut self, enum_decl: &EnumDecl) -> String {
        let mut output = String::new();

        // Generate as frozen object with symbol values
        output.push_str(&format!(
            "export const {} = Object.freeze({{\n",
            enum_decl.name
        ));

        self.indent_level += 1;
        for (i, variant) in enum_decl.variants.iter().enumerate() {
            output.push_str(&self.indent());
            output.push_str(&format!("{}: Symbol('{}')", variant.name, variant.name));
            if i < enum_decl.variants.len() - 1 {
                output.push(',');
            }
            output.push('\n');
        }
        self.indent_level -= 1;

        output.push_str("});");
        output
    }

    #[allow(clippy::only_used_in_recursion)]
    fn pattern_to_js(&self, pattern: &crate::parser::Pattern) -> String {
        match pattern {
            crate::parser::Pattern::Wildcard => "_".to_string(),
            crate::parser::Pattern::Identifier(name) => name.clone(),
            crate::parser::Pattern::Tuple(patterns) => {
                let js_patterns: Vec<String> =
                    patterns.iter().map(|p| self.pattern_to_js(p)).collect();
                format!("[{}]", js_patterns.join(", "))
            }
            crate::parser::Pattern::EnumVariant(variant, binding) => {
                // JavaScript doesn't have pattern matching like Rust, simplify
                if let Some(bind) = binding {
                    bind.clone()
                } else {
                    variant.clone()
                }
            }
            crate::parser::Pattern::Literal(lit) => {
                // This is unusual for a for loop pattern, but handle it
                format!("{:?}", lit)
            }
            crate::parser::Pattern::Or(_) => {
                // Or patterns don't work in for loops, use wildcard
                "_".to_string()
            }
        }
    }

    fn generate_statement(&mut self, stmt: &Statement) -> String {
        let mut output = String::new();

        match stmt {
            Statement::Let {
                name,
                value,
                mutable,
                ..
            } => {
                output.push_str(&self.indent());
                if *mutable {
                    output.push_str("let ");
                } else {
                    output.push_str("const ");
                }
                output.push_str(name);
                output.push_str(" = ");
                output.push_str(&self.generate_expression(value));
                output.push_str(";\n");
            }

            Statement::Const { name, value, .. } => {
                output.push_str(&self.indent());
                output.push_str(&format!(
                    "const {} = {};\n",
                    name,
                    self.generate_expression(value)
                ));
            }

            Statement::Assignment { target, value } => {
                output.push_str(&self.indent());
                output.push_str(&format!(
                    "{} = {};\n",
                    self.generate_expression(target),
                    self.generate_expression(value)
                ));
            }

            Statement::Return(expr) => {
                output.push_str(&self.indent());
                output.push_str("return");
                if let Some(e) = expr {
                    output.push(' ');
                    output.push_str(&self.generate_expression(e));
                }
                output.push_str(";\n");
            }

            Statement::Expression(expr) => {
                output.push_str(&self.indent());
                output.push_str(&self.generate_expression(expr));
                output.push_str(";\n");
            }

            Statement::If {
                condition,
                then_block,
                else_block,
            } => {
                output.push_str(&self.indent());
                output.push_str("if (");
                output.push_str(&self.generate_expression(condition));
                output.push_str(") {\n");

                self.indent_level += 1;
                for s in then_block {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push('}');

                if let Some(else_stmts) = else_block {
                    output.push_str(" else {\n");
                    self.indent_level += 1;
                    for s in else_stmts {
                        output.push_str(&self.generate_statement(s));
                    }
                    self.indent_level -= 1;
                    output.push_str(&self.indent());
                    output.push('}');
                }
                output.push('\n');
            }

            Statement::While { condition, body } => {
                output.push_str(&self.indent());
                output.push_str("while (");
                output.push_str(&self.generate_expression(condition));
                output.push_str(") {\n");

                self.indent_level += 1;
                for s in body {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push_str("}\n");
            }

            Statement::For {
                pattern,
                iterable,
                body,
            } => {
                output.push_str(&self.indent());
                output.push_str(&format!(
                    "for (const {} of {}) {{\n",
                    self.pattern_to_js(pattern),
                    self.generate_expression(iterable)
                ));

                self.indent_level += 1;
                for s in body {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push_str("}\n");
            }

            Statement::Loop { body } => {
                output.push_str(&self.indent());
                output.push_str("while (true) {\n");

                self.indent_level += 1;
                for s in body {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push_str("}\n");
            }

            Statement::Match { value, arms } => {
                // Translate match to if-else chain (simplified)
                output.push_str(&self.indent());
                output.push_str(&format!(
                    "// Match on {}\n",
                    self.generate_expression(value)
                ));
                output.push_str(&self.indent());
                output.push_str("{\n");

                self.indent_level += 1;
                output.push_str(&self.indent());
                output.push_str(&format!(
                    "const __match_value = {};\n",
                    self.generate_expression(value)
                ));

                for (i, arm) in arms.iter().enumerate() {
                    output.push_str(&self.indent());
                    if i == 0 {
                        output.push_str("if (");
                    } else {
                        output.push_str("else if (");
                    }
                    output.push_str(&self.generate_pattern_match(&arm.pattern, "__match_value"));
                    if let Some(ref guard) = arm.guard {
                        output.push_str(" && ");
                        output.push_str(&self.generate_expression(guard));
                    }
                    output.push_str(") {\n");

                    self.indent_level += 1;
                    output.push_str(&self.indent());
                    output.push_str(&format!(
                        "return {};\n",
                        self.generate_expression(&arm.body)
                    ));
                    self.indent_level -= 1;

                    output.push_str(&self.indent());
                    output.push_str("}\n");
                }

                self.indent_level -= 1;
                output.push_str(&self.indent());
                output.push_str("}\n");
            }

            Statement::Go { body } => {
                // Translate go{} to Promise or setTimeout
                output.push_str(&self.indent());
                output.push_str("Promise.resolve().then(() => {\n");

                self.indent_level += 1;
                for s in body {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push_str("});\n");
            }

            Statement::Break => {
                output.push_str(&self.indent());
                output.push_str("break;\n");
            }

            Statement::Continue => {
                output.push_str(&self.indent());
                output.push_str("continue;\n");
            }

            Statement::Use { path, alias } => {
                output.push_str(&self.indent());
                // In JavaScript, we use import or require, but for local scope we can just skip it
                // since JavaScript modules work differently. For now, add a comment.
                output.push_str(&format!(
                    "// use {} {}\n",
                    path.join("."),
                    alias
                        .as_ref()
                        .map_or(String::new(), |a| format!("as {}", a))
                ));
            }

            Statement::Defer(_) => {
                output.push_str(&self.indent());
                output.push_str("// TODO: Defer not yet supported in JavaScript\n");
            }

            Statement::Static { .. } => {
                // Handled at item level
            }
        }

        output
    }

    fn generate_expression(&mut self, expr: &Expression) -> String {
        match expr {
            Expression::Literal(lit) => self.generate_literal(lit),

            Expression::Identifier(id) => id.clone(),

            Expression::Binary { left, op, right } => {
                format!(
                    "({} {} {})",
                    self.generate_expression(left),
                    self.binary_op_to_js(op),
                    self.generate_expression(right)
                )
            }

            Expression::Ternary {
                condition,
                true_expr,
                false_expr,
            } => {
                format!(
                    "({} ? {} : {})",
                    self.generate_expression(condition),
                    self.generate_expression(true_expr),
                    self.generate_expression(false_expr)
                )
            }

            Expression::Unary { op, operand } => {
                format!(
                    "({}{})",
                    self.unary_op_to_js(op),
                    self.generate_expression(operand)
                )
            }

            Expression::Call {
                function,
                arguments,
            } => {
                let func_expr = self.generate_expression(function);

                // Handle special functions
                if func_expr == "println!" {
                    let args: Vec<String> = arguments
                        .iter()
                        .map(|(_, arg)| self.generate_expression(arg))
                        .collect();
                    return format!("console.log({})", args.join(", "));
                }

                let args: Vec<String> = arguments
                    .iter()
                    .map(|(_, arg)| self.generate_expression(arg))
                    .collect();
                format!("{}({})", func_expr, args.join(", "))
            }

            Expression::MethodCall {
                object,
                method,
                arguments,
                ..
            } => {
                let obj = self.generate_expression(object);
                let args: Vec<String> = arguments
                    .iter()
                    .map(|(_, arg)| self.generate_expression(arg))
                    .collect();
                format!("{}.{}({})", obj, method, args.join(", "))
            }

            Expression::FieldAccess { object, field } => {
                format!("{}.{}", self.generate_expression(object), field)
            }

            Expression::StructLiteral { name, fields } => {
                let field_strs: Vec<String> = fields
                    .iter()
                    .map(|(field_name, expr)| {
                        format!("{}: {}", field_name, self.generate_expression(expr))
                    })
                    .collect();
                format!(
                    "new {}({})",
                    name,
                    field_strs
                        .iter()
                        .map(|f| { f.split(": ").nth(1).unwrap_or("") })
                        .collect::<Vec<_>>()
                        .join(", ")
                )
            }

            Expression::Index { object, index } => {
                format!(
                    "{}[{}]",
                    self.generate_expression(object),
                    self.generate_expression(index)
                )
            }

            Expression::Tuple(elements) => {
                let elems: Vec<String> = elements
                    .iter()
                    .map(|e| self.generate_expression(e))
                    .collect();
                format!("[{}]", elems.join(", "))
            }

            Expression::Array(elements) => {
                let elems: Vec<String> = elements
                    .iter()
                    .map(|e| self.generate_expression(e))
                    .collect();
                format!("[{}]", elems.join(", "))
            }

            Expression::MacroInvocation { name, args, .. } => {
                // Handle common macros
                match name.as_str() {
                    "vec" => {
                        let elems: Vec<String> =
                            args.iter().map(|e| self.generate_expression(e)).collect();
                        format!("[{}]", elems.join(", "))
                    }
                    "println" | "print" => {
                        let args_str: Vec<String> =
                            args.iter().map(|e| self.generate_expression(e)).collect();
                        format!("console.log({})", args_str.join(", "))
                    }
                    "format" => {
                        // String formatting - just use template literal
                        let args_str: Vec<String> =
                            args.iter().map(|e| self.generate_expression(e)).collect();
                        if args_str.len() == 1 {
                            args_str[0].clone()
                        } else {
                            format!("`{}`", args_str.join(" "))
                        }
                    }
                    _ => format!("/* macro: {}! */", name),
                }
            }

            Expression::Await(expr) => {
                format!("await {}", self.generate_expression(expr))
            }

            Expression::TryOp(expr) => {
                // Simplify: just return the expression (proper error handling needs runtime support)
                self.generate_expression(expr)
            }

            Expression::Range {
                start,
                end,
                inclusive,
            } => {
                // Generate array from range
                if *inclusive {
                    format!(
                        "Array.from({{length: {} - {} + 1}}, (_, i) => {} + i)",
                        self.generate_expression(end),
                        self.generate_expression(start),
                        self.generate_expression(start)
                    )
                } else {
                    format!(
                        "Array.from({{length: {} - {}}}, (_, i) => {} + i)",
                        self.generate_expression(end),
                        self.generate_expression(start),
                        self.generate_expression(start)
                    )
                }
            }

            Expression::Closure { parameters, body } => {
                format!(
                    "({}) => {}",
                    parameters.join(", "),
                    self.generate_expression(body)
                )
            }

            Expression::Cast { expr, .. } => {
                // Just return the expression (JS is dynamically typed)
                self.generate_expression(expr)
            }

            Expression::ChannelSend { channel, value } => {
                // Simplified: treat as method call
                format!(
                    "{}.send({})",
                    self.generate_expression(channel),
                    self.generate_expression(value)
                )
            }

            Expression::ChannelRecv(channel) => {
                format!("{}.receive()", self.generate_expression(channel))
            }

            Expression::Block(statements) => {
                let mut output = String::from("(() => {\n");
                self.indent_level += 1;
                for stmt in statements {
                    output.push_str(&self.generate_statement(stmt));
                }
                self.indent_level -= 1;
                output.push_str(&self.indent());
                output.push_str("})()");
                output
            }
        }
    }

    fn generate_literal(&self, lit: &Literal) -> String {
        match lit {
            Literal::Int(n) => n.to_string(),
            Literal::Float(f) => f.to_string(),
            Literal::String(s) => {
                // Check for string interpolation markers (${ or just $ with identifier)
                if s.contains("${") || s.contains("$") {
                    // Use template literal with backticks for interpolation
                    format!("`{}`", s)
                } else {
                    // Use single quotes for plain strings
                    format!("'{}'", s.replace('\'', "\\'"))
                }
            }
            Literal::Char(c) => format!("'{}'", c),
            Literal::Bool(b) => b.to_string(),
        }
    }

    fn generate_pattern_match(&self, pattern: &Pattern, match_value: &str) -> String {
        match pattern {
            Pattern::Wildcard => "true".to_string(),
            Pattern::Identifier(id) => format!("(({} = {}) || true)", id, match_value),
            Pattern::Literal(lit) => format!("{} === {}", match_value, self.generate_literal(lit)),
            Pattern::EnumVariant(name, binding) => {
                if let Some(var) = binding {
                    format!("{} === {}.{}", match_value, name, var)
                } else {
                    format!("{} === {}", match_value, name)
                }
            }
            Pattern::Or(patterns) => {
                let conditions: Vec<String> = patterns
                    .iter()
                    .map(|p| self.generate_pattern_match(p, match_value))
                    .collect();
                format!("({})", conditions.join(" || "))
            }
            Pattern::Tuple(_) => format!("Array.isArray({})", match_value),
        }
    }

    fn binary_op_to_js(&self, op: &BinaryOp) -> String {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Sub => "-",
            BinaryOp::Mul => "*",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::Eq => "===",
            BinaryOp::Ne => "!==",
            BinaryOp::Lt => "<",
            BinaryOp::Le => "<=",
            BinaryOp::Gt => ">",
            BinaryOp::Ge => ">=",
            BinaryOp::And => "&&",
            BinaryOp::Or => "||",
        }
        .to_string()
    }

    fn unary_op_to_js(&self, op: &UnaryOp) -> String {
        match op {
            UnaryOp::Not => "!".to_string(),
            UnaryOp::Neg => "-".to_string(),
            UnaryOp::Ref => "".to_string(), // & doesn't apply in JS (auto-reference)
            UnaryOp::Deref => "".to_string(), // * doesn't apply in JS
        }
    }

    fn type_to_jsdoc(ty: &Type) -> String {
        match ty {
            Type::Int | Type::Int32 | Type::Uint | Type::Float => "number".to_string(),
            Type::String => "string".to_string(),
            Type::Bool => "boolean".to_string(),
            Type::Custom(name) => name.clone(),
            Type::Generic(name) => name.clone(),
            Type::Vec(inner) => format!("Array<{}>", Self::type_to_jsdoc(inner)),
            Type::Option(inner) => format!("{}|null", Self::type_to_jsdoc(inner)),
            _ => "any".to_string(),
        }
    }

    fn indent(&self) -> String {
        "    ".repeat(self.indent_level)
    }
}

impl Default for JavaScriptGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_empty_program() {
        let mut gen = JavaScriptGenerator::new();
        let program = Program { items: vec![] };
        let code = gen.generate(&program);
        assert!(code.contains("Windjammer JavaScript transpiler"));
    }

    #[test]
    fn test_generate_simple_function() {
        let mut gen = JavaScriptGenerator::new();
        let program = Program {
            items: vec![Item::Function(FunctionDecl {
                name: "greet".to_string(),
                parameters: vec![],
                return_type: None,
                body: vec![],
                decorators: vec![],
                is_async: false,
                type_params: vec![],
                where_clause: vec![],
            })],
        };

        let code = gen.generate(&program);
        assert!(code.contains("export function greet"));
    }

    #[test]
    fn test_generate_literal() {
        let gen = JavaScriptGenerator::new();
        assert_eq!(gen.generate_literal(&Literal::Int(42)), "42");
        assert_eq!(
            gen.generate_literal(&Literal::String("hello".to_string())),
            "'hello'"
        );
        assert_eq!(gen.generate_literal(&Literal::Bool(true)), "true");
    }

    #[test]
    fn test_binary_op_conversion() {
        let gen = JavaScriptGenerator::new();
        assert_eq!(gen.binary_op_to_js(&BinaryOp::Eq), "===");
        assert_eq!(gen.binary_op_to_js(&BinaryOp::Ne), "!==");
        assert_eq!(gen.binary_op_to_js(&BinaryOp::And), "&&");
        assert_eq!(gen.binary_op_to_js(&BinaryOp::Add), "+");
    }
}
