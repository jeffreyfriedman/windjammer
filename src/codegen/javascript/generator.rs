//! JavaScript code generator (ES2020+)
//!
//! Generates clean, idiomatic JavaScript from Windjammer AST

use crate::parser::*;
use std::collections::HashMap;

pub struct JavaScriptGenerator {
    indent_level: usize,
    async_functions: HashMap<String, bool>,
    /// Impl methods collected per type name, to inject into class bodies
    impl_methods: HashMap<String, Vec<(String, Vec<String>)>>,
    /// Track variable declarations per scope for shadowing → renaming.
    /// Maps original name → current JS name (e.g., "x" → "x$2")
    var_scopes: Vec<HashMap<String, String>>,
    /// Counter for generating unique shadowed variable names
    shadow_counter: HashMap<String, usize>,
}

impl JavaScriptGenerator {
    pub fn new() -> Self {
        Self {
            indent_level: 0,
            async_functions: HashMap::new(),
            impl_methods: HashMap::new(),
            var_scopes: vec![HashMap::new()],
            shadow_counter: HashMap::new(),
        }
    }

    /// Push a new variable scope (function body, block, etc.)
    fn push_var_scope(&mut self) {
        self.var_scopes.push(HashMap::new());
    }

    /// Pop the current variable scope
    fn pop_var_scope(&mut self) {
        self.var_scopes.pop();
    }

    /// Declare a variable, generating a renamed version if it shadows an existing one.
    /// Returns the JS name to use.
    fn declare_var(&mut self, name: &str) -> String {
        // Check if this name is already declared in any scope
        let already_exists = self.var_scopes.iter().any(|s| s.contains_key(name));
        let js_name = if already_exists {
            let counter = self.shadow_counter.entry(name.to_string()).or_insert(0);
            *counter += 1;
            format!("{}${}", name, counter)
        } else {
            name.to_string()
        };
        // Register in current scope
        if let Some(scope) = self.var_scopes.last_mut() {
            scope.insert(name.to_string(), js_name.clone());
        }
        js_name
    }

    /// Resolve a variable reference to its current JS name
    fn resolve_var(&self, name: &str) -> String {
        // Search scopes from innermost to outermost
        for scope in self.var_scopes.iter().rev() {
            if let Some(js_name) = scope.get(name) {
                return js_name.clone();
            }
        }
        name.to_string()
    }

    pub fn generate(&mut self, program: &Program) -> String {
        let mut output = String::new();

        // Add file header
        output.push_str("// Generated by Windjammer JavaScript transpiler (v0.32.0)\n");
        output.push_str("// https://windjammer.dev\n\n");

        // First pass: Detect async functions
        self.detect_async_functions(program);

        // Second pass: Collect impl methods per type
        self.collect_impl_methods(program);

        // Generate each item
        for item in &program.items {
            let code = self.generate_item(item);
            if !code.is_empty() {
                output.push_str(&code);
                output.push_str("\n\n");
            }
        }

        // Add auto-run main if it exists
        if self.has_main_function(program) {
            output.push_str(&self.generate_auto_run_main());
        }

        output
    }

    fn detect_async_functions(&mut self, program: &Program) {
        for item in &program.items {
            if let Item::Function { decl: func, .. } = item {
                let is_async = func.is_async || self.contains_await_in_body(&func.body);
                self.async_functions.insert(func.name.clone(), is_async);
            }
        }
    }

    fn contains_await_in_body<'ast>(&self, statements: &[&'ast Statement<'ast>]) -> bool {
        statements.iter().any(|s| Self::contains_await_stmt(s))
    }

    fn contains_await_stmt(stmt: &Statement) -> bool {
        match stmt {
            Statement::Expression { expr, .. } => Self::contains_await_expr(expr),
            Statement::Let { value, .. } => Self::contains_await_expr(value),
            Statement::Return {
                value: Some(expr), ..
            } => Self::contains_await_expr(expr),
            Statement::If {
                condition,
                then_block,
                else_block,
                ..
            } => {
                Self::contains_await_expr(condition)
                    || then_block.iter().any(|s| Self::contains_await_stmt(s))
                    || else_block
                        .as_ref()
                        .is_some_and(|block| block.iter().any(|s| Self::contains_await_stmt(s)))
            }
            _ => false,
        }
    }

    fn contains_await_expr(expr: &Expression) -> bool {
        match expr {
            Expression::Await { .. } => true,
            Expression::Binary { left, right, .. } => {
                Self::contains_await_expr(left) || Self::contains_await_expr(right)
            }
            Expression::Call {
                function,
                arguments,
                ..
            } => {
                Self::contains_await_expr(function)
                    || arguments
                        .iter()
                        .any(|(_, arg)| Self::contains_await_expr(arg))
            }
            Expression::MethodCall {
                object, arguments, ..
            } => {
                Self::contains_await_expr(object)
                    || arguments
                        .iter()
                        .any(|(_, arg)| Self::contains_await_expr(arg))
            }
            _ => false,
        }
    }

    fn has_main_function(&self, program: &Program) -> bool {
        program
            .items
            .iter()
            .any(|item| matches!(item, Item::Function { decl: func, .. } if func.name == "main"))
    }

    fn generate_auto_run_main(&self) -> String {
        let is_async = self.async_functions.get("main").copied().unwrap_or(false);

        if is_async {
            r#"// Auto-run main if executed directly (Node.js)
if (import.meta.url === `file://${process.argv[1]}`) {
    main().catch(console.error);
}
"#
            .to_string()
        } else {
            r#"// Auto-run main if executed directly (Node.js)
if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}
"#
            .to_string()
        }
    }

    /// Collect impl methods per type name for injection into classes
    fn collect_impl_methods(&mut self, program: &Program) {
        for item in &program.items {
            if let Item::Impl { block, .. } = item {
                let type_name = block.type_name.clone();
                let methods: Vec<(String, Vec<String>)> = block
                    .functions
                    .iter()
                    .map(|func| {
                        let method_code = self.generate_class_method(func);
                        (func.name.clone(), vec![method_code])
                    })
                    .collect();
                self.impl_methods
                    .entry(type_name)
                    .or_default()
                    .extend(methods);
            }
        }
    }

    /// Generate a method for inclusion in a class body
    fn generate_class_method(&mut self, func: &FunctionDecl) -> String {
        let mut output = String::new();
        let indent = self.indent();

        let is_async = self
            .async_functions
            .get(&func.name)
            .copied()
            .unwrap_or(false);

        // Check if this is a static method (no self parameter)
        let is_static = !func.parameters.iter().any(|p| p.name == "self");

        output.push_str(&indent);
        if is_static {
            output.push_str("static ");
        }
        if is_async {
            output.push_str("async ");
        }

        // Method name — use 'create' instead of 'new' since 'new' is reserved in JS
        let method_name = if func.name == "new" {
            "create"
        } else {
            &func.name
        };
        output.push_str(method_name);
        output.push('(');
        let params: Vec<String> = func
            .parameters
            .iter()
            .filter(|p| p.name != "self")
            .map(|p| p.name.clone())
            .collect();
        output.push_str(&params.join(", "));
        output.push_str(") {\n");

        self.indent_level += 1;
        let body_len = func.body.len();
        let has_return_type = func.return_type.is_some();
        for (i, stmt) in func.body.iter().enumerate() {
            let is_last = i == body_len - 1;
            if is_last && has_return_type {
                if let Statement::Expression { expr, .. } = stmt {
                    let indent_inner = self.indent();
                    let expr_str = self.generate_expression(expr);
                    // Replace self. with this.
                    let expr_str = expr_str.replace("self.", "this.");
                    output.push_str(&format!("{}return {};\n", indent_inner, expr_str));
                    continue;
                }
            }
            let stmt_code = self.generate_statement(stmt);
            // Replace self. with this.
            let stmt_code = stmt_code.replace("self.", "this.");
            output.push_str(&stmt_code);
        }
        self.indent_level -= 1;

        output.push_str(&self.indent());
        output.push_str("}\n");

        output
    }

    fn generate_item(&mut self, item: &Item) -> String {
        match item {
            Item::Function { decl: func, .. } => self.generate_function(func),
            Item::Struct {
                decl: struct_decl, ..
            } => self.generate_struct(struct_decl),
            Item::Enum {
                decl: enum_decl, ..
            } => self.generate_enum(enum_decl),
            Item::Trait { .. } => String::from("// Trait (use duck typing in JavaScript)"),
            Item::Impl { .. } => String::new(), // Impl blocks are merged into classes
            Item::Use { .. } => String::new(),  // Imports handled separately
            Item::Const { name, value, .. } => {
                format!(
                    "export const {} = {};\n",
                    name,
                    self.generate_expression(value)
                )
            }
            Item::Static { name, value, .. } => {
                format!(
                    "export let {} = {};\n",
                    name,
                    self.generate_expression(value)
                )
            }
            _ => "// TODO: Unsupported item type".to_string(),
        }
    }

    fn generate_function(&mut self, func: &FunctionDecl) -> String {
        let mut output = String::new();

        // Generate JSDoc
        if !func.parameters.is_empty() || func.return_type.is_some() {
            output.push_str("/**\n");
            for param in &func.parameters {
                output.push_str(&format!(
                    " * @param {{{}}} {}\n",
                    Self::type_to_jsdoc(&param.type_),
                    param.name
                ));
            }
            if let Some(ref ret_type) = func.return_type {
                output.push_str(&format!(
                    " * @returns {{{}}}\n",
                    Self::type_to_jsdoc(ret_type)
                ));
            }
            output.push_str(" */\n");
        }

        // Function declaration
        output.push_str("export ");

        let is_async = self
            .async_functions
            .get(&func.name)
            .copied()
            .unwrap_or(false);
        if is_async {
            output.push_str("async ");
        }

        output.push_str("function ");
        output.push_str(&func.name);
        output.push('(');

        // Parameters
        let params: Vec<String> = func.parameters.iter().map(|p| p.name.clone()).collect();
        output.push_str(&params.join(", "));
        output.push_str(") {\n");

        // Body
        self.push_var_scope();
        // Declare parameters in scope
        for p in &func.parameters {
            self.declare_var(&p.name);
        }
        self.indent_level += 1;
        let body_len = func.body.len();
        let has_return_type = func.return_type.is_some();
        for (i, stmt) in func.body.iter().enumerate() {
            let is_last = i == body_len - 1;
            // Auto-insert return for last expression in functions with return type
            if is_last && has_return_type {
                if let Statement::Expression { expr, .. } = stmt {
                    let indent = self.indent();
                    let expr_str = self.generate_expression(expr);
                    output.push_str(&format!("{}return {};\n", indent, expr_str));
                    continue;
                }
            }
            output.push_str(&self.generate_statement(stmt));
        }
        self.indent_level -= 1;
        self.pop_var_scope();

        output.push('}');
        output
    }

    fn generate_struct(&mut self, struct_decl: &StructDecl) -> String {
        let mut output = String::new();

        output.push_str(&format!("export class {} {{\n", struct_decl.name));
        self.indent_level += 1;

        // Constructor
        output.push_str(&self.indent());
        output.push_str("constructor(");
        let params: Vec<String> = struct_decl.fields.iter().map(|f| f.name.clone()).collect();
        output.push_str(&params.join(", "));
        output.push_str(") {\n");

        self.indent_level += 1;
        for field in &struct_decl.fields {
            output.push_str(&self.indent());
            output.push_str(&format!("this.{} = {};\n", field.name, field.name));
        }
        self.indent_level -= 1;

        output.push_str(&self.indent());
        output.push_str("}\n");

        // Inject impl methods if any exist for this type
        if let Some(methods) = self.impl_methods.get(&struct_decl.name).cloned() {
            for (_method_name, code_parts) in &methods {
                output.push('\n');
                for code in code_parts {
                    output.push_str(code);
                }
            }
        }

        self.indent_level -= 1;
        output.push('}');
        output
    }

    fn generate_enum(&mut self, enum_decl: &EnumDecl) -> String {
        let mut output = String::new();

        // Generate enum as a frozen object.
        // - Unit variants → unique string tags (comparable with ===)
        // - Tuple/struct variants → factory functions returning tagged objects
        output.push_str(&format!(
            "export const {} = Object.freeze({{\n",
            enum_decl.name
        ));

        self.indent_level += 1;
        for (i, variant) in enum_decl.variants.iter().enumerate() {
            output.push_str(&self.indent());
            let tag = format!("{}.{}", enum_decl.name, variant.name);
            match &variant.data {
                EnumVariantData::Unit => {
                    // Unit variant: Color.Red === 'Color.Red'
                    output.push_str(&format!("{}: '{}'", variant.name, tag));
                }
                EnumVariantData::Tuple(types) => {
                    // Tuple variant: Shape.Circle(5) → { type: 'Shape.Circle', value: [5] }
                    let params: Vec<String> = (0..types.len()).map(|i| format!("v{}", i)).collect();
                    output.push_str(&format!(
                        "{}: ({}) => ({{ type: '{}', value: [{}] }})",
                        variant.name,
                        params.join(", "),
                        tag,
                        params.join(", ")
                    ));
                }
                EnumVariantData::Struct(fields) => {
                    // Struct variant: Event.Click { x, y } → { type: 'Event.Click', value: { x, y } }
                    let params: Vec<String> = fields.iter().map(|(n, _)| n.clone()).collect();
                    output.push_str(&format!(
                        "{}: ({}) => ({{ type: '{}', value: {{ {} }} }})",
                        variant.name,
                        params.join(", "),
                        tag,
                        params.join(", ")
                    ));
                }
            }
            if i < enum_decl.variants.len() - 1 {
                output.push(',');
            }
            output.push('\n');
        }
        self.indent_level -= 1;

        output.push_str("});");
        output
    }

    #[allow(clippy::only_used_in_recursion)]
    fn pattern_to_js(&self, pattern: &crate::parser::Pattern) -> String {
        match pattern {
            crate::parser::Pattern::Wildcard => "_".to_string(),
            crate::parser::Pattern::Identifier(name) => name.clone(),
            crate::parser::Pattern::Reference(inner) => {
                // JavaScript doesn't have references, just use the inner pattern
                self.pattern_to_js(inner)
            }
            crate::parser::Pattern::Tuple(patterns) => {
                let js_patterns: Vec<String> =
                    patterns.iter().map(|p| self.pattern_to_js(p)).collect();
                format!("[{}]", js_patterns.join(", "))
            }
            crate::parser::Pattern::EnumVariant(variant, binding) => {
                use crate::parser::EnumPatternBinding;
                // JavaScript doesn't have pattern matching like Rust, simplify
                match binding {
                    EnumPatternBinding::Single(bind) => bind.clone(),
                    EnumPatternBinding::Wildcard | EnumPatternBinding::None => variant.clone(),
                    _ => variant.clone(), // Tuple and Struct patterns also simplified to variant name
                }
            }
            crate::parser::Pattern::Literal(lit) => {
                // This is unusual for a for loop pattern, but handle it
                format!("{:?}", lit)
            }
            crate::parser::Pattern::Or(_) => {
                // Or patterns don't work in for loops, use wildcard
                "_".to_string()
            }
        }
    }

    fn generate_statement(&mut self, stmt: &Statement) -> String {
        let mut output = String::new();

        match stmt {
            Statement::Let {
                pattern,
                value,
                mutable: _,
                ..
            } => {
                // Always use `let` in JS: Windjammer enforces immutability at compile time.
                // Handle shadowing by renaming variables (JS can't re-declare let in same scope).
                let val_str = self.generate_expression(value);
                output.push_str(&self.indent());
                output.push_str("let ");
                // For simple identifier patterns, use the shadow-safe name
                if let Pattern::Identifier(name) = pattern {
                    let js_name = self.declare_var(name);
                    output.push_str(&js_name);
                } else {
                    output.push_str(&self.generate_pattern(pattern));
                }
                output.push_str(" = ");
                output.push_str(&val_str);
                output.push_str(";\n");
            }

            Statement::Const { name, value, .. } => {
                output.push_str(&self.indent());
                output.push_str(&format!(
                    "const {} = {};\n",
                    name,
                    self.generate_expression(value)
                ));
            }

            Statement::Assignment {
                target,
                value,
                compound_op,
                ..
            } => {
                output.push_str(&self.indent());
                let op_str = match compound_op {
                    Some(CompoundOp::Add) => "+=",
                    Some(CompoundOp::Sub) => "-=",
                    Some(CompoundOp::Mul) => "*=",
                    Some(CompoundOp::Div) => "/=",
                    Some(CompoundOp::Mod) => "%=",
                    Some(CompoundOp::BitAnd) => "&=",
                    Some(CompoundOp::BitOr) => "|=",
                    Some(CompoundOp::BitXor) => "^=",
                    Some(CompoundOp::Shl) => "<<=",
                    Some(CompoundOp::Shr) => ">>=",
                    None => "=",
                };
                output.push_str(&format!(
                    "{} {} {};\n",
                    self.generate_expression(target),
                    op_str,
                    self.generate_expression(value)
                ));
            }

            Statement::Return { value: expr, .. } => {
                output.push_str(&self.indent());
                output.push_str("return");
                if let Some(e) = expr {
                    output.push(' ');
                    output.push_str(&self.generate_expression(e));
                }
                output.push_str(";\n");
            }

            Statement::Expression { expr, .. } => {
                output.push_str(&self.indent());
                output.push_str(&self.generate_expression(expr));
                output.push_str(";\n");
            }

            Statement::If {
                condition,
                then_block,
                else_block,
                ..
            } => {
                output.push_str(&self.indent());
                output.push_str("if (");
                output.push_str(&self.generate_expression(condition));
                output.push_str(") {\n");

                self.indent_level += 1;
                for s in then_block {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push('}');

                if let Some(else_stmts) = else_block {
                    output.push_str(" else {\n");
                    self.indent_level += 1;
                    for s in else_stmts {
                        output.push_str(&self.generate_statement(s));
                    }
                    self.indent_level -= 1;
                    output.push_str(&self.indent());
                    output.push('}');
                }
                output.push('\n');
            }

            Statement::While {
                condition, body, ..
            } => {
                output.push_str(&self.indent());
                output.push_str("while (");
                output.push_str(&self.generate_expression(condition));
                output.push_str(") {\n");

                self.indent_level += 1;
                for s in body {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push_str("}\n");
            }

            Statement::For {
                pattern,
                iterable,
                body,
                ..
            } => {
                output.push_str(&self.indent());
                output.push_str(&format!(
                    "for (const {} of {}) {{\n",
                    self.pattern_to_js(pattern),
                    self.generate_expression(iterable)
                ));

                self.indent_level += 1;
                for s in body {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push_str("}\n");
            }

            Statement::Loop { body, .. } => {
                output.push_str(&self.indent());
                output.push_str("while (true) {\n");

                self.indent_level += 1;
                for s in body {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push_str("}\n");
            }

            Statement::Match { value, arms, .. } => {
                // Translate match to if-else chain
                output.push_str(&self.indent());
                output.push_str("{\n");

                self.indent_level += 1;
                output.push_str(&self.indent());
                output.push_str(&format!(
                    "let __match_value = {};\n",
                    self.generate_expression(value)
                ));

                // Pre-declare any variables used in guard patterns (e.g., `x if x > 0`)
                // so they're in scope for both the binding and the guard expression.
                // Deduplicate: multiple arms may bind the same variable name.
                {
                    let mut declared = std::collections::HashSet::new();
                    for arm in arms.iter() {
                        if let Pattern::Identifier(id) = &arm.pattern {
                            if id != "_" && declared.insert(id.clone()) {
                                output.push_str(&self.indent());
                                output.push_str(&format!("let {};\n", id));
                            }
                        }
                    }
                }

                for (i, arm) in arms.iter().enumerate() {
                    output.push_str(&self.indent());
                    if i == 0 {
                        output.push_str("if (");
                    } else {
                        output.push_str("else if (");
                    }
                    output.push_str(&self.generate_pattern_match(&arm.pattern, "__match_value"));
                    if let Some(guard) = arm.guard {
                        output.push_str(" && ");
                        output.push_str(&self.generate_expression(guard));
                    }
                    output.push_str(") {\n");

                    self.indent_level += 1;
                    output.push_str(&self.indent());
                    output.push_str(&format!("return {};\n", self.generate_expression(arm.body)));
                    self.indent_level -= 1;

                    output.push_str(&self.indent());
                    output.push_str("}\n");
                }

                self.indent_level -= 1;
                output.push_str(&self.indent());
                output.push_str("}\n");
            }

            Statement::Thread { body, .. } => {
                // Thread in JS = Web Worker or setTimeout (for demo)
                output.push_str(&self.indent());
                output.push_str("// Note: true threading requires Web Workers\n");
                output.push_str(&self.indent());
                output.push_str("setTimeout(() => {\n");

                self.indent_level += 1;
                for s in body {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push_str("}, 0);\n");
            }

            Statement::Async { body, .. } => {
                // Async in JS = Promise
                output.push_str(&self.indent());
                output.push_str("Promise.resolve().then(async () => {\n");

                self.indent_level += 1;
                for s in body {
                    output.push_str(&self.generate_statement(s));
                }
                self.indent_level -= 1;

                output.push_str(&self.indent());
                output.push_str("});\n");
            }

            Statement::Break { .. } => {
                output.push_str(&self.indent());
                output.push_str("break;\n");
            }

            Statement::Continue { .. } => {
                output.push_str(&self.indent());
                output.push_str("continue;\n");
            }

            Statement::Use { path, alias, .. } => {
                output.push_str(&self.indent());
                // In JavaScript, we use import or require, but for local scope we can just skip it
                // since JavaScript modules work differently. For now, add a comment.
                output.push_str(&format!(
                    "// use {} {}\n",
                    path.join("."),
                    alias
                        .as_ref()
                        .map_or(String::new(), |a| format!("as {}", a))
                ));
            }

            Statement::Defer { .. } => {
                output.push_str(&self.indent());
                output.push_str("// TODO: Defer not yet supported in JavaScript\n");
            }

            Statement::Static { .. } => {
                // Handled at item level
            }
        }

        output
    }

    fn generate_expression(&mut self, expr: &Expression) -> String {
        match expr {
            Expression::Literal { value: lit, .. } => self.generate_literal(lit),

            Expression::Identifier { name: id, .. } => {
                // Convert Rust-style path syntax (Type::Variant) to JS dot notation (Type.Variant)
                if id.contains("::") {
                    id.replace("::", ".")
                } else {
                    // Resolve shadowed variable names
                    self.resolve_var(id)
                }
            }

            Expression::Binary {
                left, op, right, ..
            } => {
                format!(
                    "({} {} {})",
                    self.generate_expression(left),
                    self.binary_op_to_js(op),
                    self.generate_expression(right)
                )
            }

            Expression::Unary { op, operand, .. } => {
                format!(
                    "({}{})",
                    self.unary_op_to_js(op),
                    self.generate_expression(operand)
                )
            }

            Expression::Call {
                function,
                arguments,
                ..
            } => {
                let func_expr = self.generate_expression(function);

                // Handle special functions
                match func_expr.as_str() {
                    "println!" | "println" => {
                        let args: Vec<String> = arguments
                            .iter()
                            .map(|(_, arg)| self.generate_expression(arg))
                            .collect();
                        return self.generate_js_println(&args);
                    }
                    "print!" | "print" => {
                        let args: Vec<String> = arguments
                            .iter()
                            .map(|(_, arg)| self.generate_expression(arg))
                            .collect();
                        return self.generate_js_print(&args);
                    }
                    _ => {}
                }

                // Handle Type.new(...) → Type.create(...) since 'new' is reserved
                let func_expr = if func_expr.ends_with(".new") {
                    format!("{}.create", &func_expr[..func_expr.len() - 4])
                } else {
                    func_expr
                };

                let args: Vec<String> = arguments
                    .iter()
                    .map(|(_, arg)| self.generate_expression(arg))
                    .collect();
                format!("{}({})", func_expr, args.join(", "))
            }

            Expression::MethodCall {
                object,
                method,
                arguments,
                ..
            } => {
                let obj = self.generate_expression(object);
                let args: Vec<String> = arguments
                    .iter()
                    .map(|(_, arg)| self.generate_expression(arg))
                    .collect();
                // Map Windjammer/Rust methods to JS equivalents
                match method.as_str() {
                    "len" => format!("{}.length", obj), // .len() → .length (property, not method)
                    "is_empty" => format!("{}.length === 0", obj),
                    "contains" if args.len() == 1 => format!("{}.includes({})", obj, args[0]),
                    "to_string" => format!("String({})", obj),
                    _ => format!("{}.{}({})", obj, method, args.join(", ")),
                }
            }

            Expression::FieldAccess { object, field, .. } => {
                format!("{}.{}", self.generate_expression(object), field)
            }

            Expression::StructLiteral { name, fields, .. } => {
                let field_strs: Vec<String> = fields
                    .iter()
                    .map(|(field_name, expr)| {
                        format!("{}: {}", field_name, self.generate_expression(expr))
                    })
                    .collect();
                format!(
                    "new {}({})",
                    name,
                    field_strs
                        .iter()
                        .map(|f| { f.split(": ").nth(1).unwrap_or("") })
                        .collect::<Vec<_>>()
                        .join(", ")
                )
            }

            Expression::MapLiteral { pairs, .. } => {
                // Generate JavaScript object literal: {key: value, ...}
                if pairs.is_empty() {
                    "{}".to_string()
                } else {
                    let entries_str: Vec<String> = pairs
                        .iter()
                        .map(|(k, v)| {
                            let key_str = self.generate_expression(k);
                            let val_str = self.generate_expression(v);
                            // If key is a simple identifier or string literal, use it directly
                            // Otherwise, use computed property: [key]: value
                            if matches!(
                                k,
                                Expression::Literal {
                                    value: Literal::String(_),
                                    ..
                                } | Expression::Identifier { .. }
                            ) {
                                format!("{}: {}", key_str, val_str)
                            } else {
                                format!("[{}]: {}", key_str, val_str)
                            }
                        })
                        .collect();
                    format!("{{ {} }}", entries_str.join(", "))
                }
            }

            Expression::Index { object, index, .. } => {
                format!(
                    "{}[{}]",
                    self.generate_expression(object),
                    self.generate_expression(index)
                )
            }

            Expression::Tuple { elements, .. } => {
                let elems: Vec<String> = elements
                    .iter()
                    .map(|e| self.generate_expression(e))
                    .collect();
                format!("[{}]", elems.join(", "))
            }

            Expression::Array { elements, .. } => {
                let elems: Vec<String> = elements
                    .iter()
                    .map(|e| self.generate_expression(e))
                    .collect();
                format!("[{}]", elems.join(", "))
            }

            Expression::MacroInvocation { name, args, .. } => {
                // Handle common macros
                match name.as_str() {
                    "vec" => {
                        let elems: Vec<String> =
                            args.iter().map(|e| self.generate_expression(e)).collect();
                        format!("[{}]", elems.join(", "))
                    }
                    "println" | "print" => {
                        let args_str: Vec<String> =
                            args.iter().map(|e| self.generate_expression(e)).collect();
                        format!("console.log({})", args_str.join(", "))
                    }
                    "format" => {
                        // Convert format!("Hello, {}!", name) → `Hello, ${name}!`
                        let args_str: Vec<String> =
                            args.iter().map(|e| self.generate_expression(e)).collect();
                        if args_str.len() <= 1 {
                            args_str
                                .first()
                                .cloned()
                                .unwrap_or_else(|| "''".to_string())
                        } else {
                            // First arg is the format string (quoted), rest are values
                            let fmt = &args_str[0];
                            // Strip quotes from format string
                            let inner = if (fmt.starts_with('\'') && fmt.ends_with('\''))
                                || (fmt.starts_with('"') && fmt.ends_with('"'))
                            {
                                &fmt[1..fmt.len() - 1]
                            } else {
                                fmt.as_str()
                            };
                            // Replace {} placeholders with ${arg} expressions
                            let mut result = String::new();
                            let mut arg_idx = 0;
                            let mut chars = inner.chars().peekable();
                            while let Some(ch) = chars.next() {
                                if ch == '{' && chars.peek() == Some(&'}') {
                                    chars.next(); // consume }
                                    if arg_idx + 1 < args_str.len() {
                                        result.push_str(&format!("${{{}}}", args_str[arg_idx + 1]));
                                        arg_idx += 1;
                                    } else {
                                        result.push_str("{}");
                                    }
                                } else {
                                    result.push(ch);
                                }
                            }
                            format!("`{}`", result)
                        }
                    }
                    _ => format!("/* macro: {}! */", name),
                }
            }

            Expression::Await { expr, .. } => {
                format!("await {}", self.generate_expression(expr))
            }

            Expression::TryOp { expr, .. } => {
                // Simplify: just return the expression (proper error handling needs runtime support)
                self.generate_expression(expr)
            }

            Expression::Range {
                start,
                end,
                inclusive,
                ..
            } => {
                // Generate array from range
                if *inclusive {
                    format!(
                        "Array.from({{length: {} - {} + 1}}, (_, i) => {} + i)",
                        self.generate_expression(end),
                        self.generate_expression(start),
                        self.generate_expression(start)
                    )
                } else {
                    format!(
                        "Array.from({{length: {} - {}}}, (_, i) => {} + i)",
                        self.generate_expression(end),
                        self.generate_expression(start),
                        self.generate_expression(start)
                    )
                }
            }

            Expression::Closure {
                parameters, body, ..
            } => {
                format!(
                    "({}) => {}",
                    parameters.join(", "),
                    self.generate_expression(body)
                )
            }

            Expression::Cast { expr, .. } => {
                // Just return the expression (JS is dynamically typed)
                self.generate_expression(expr)
            }

            Expression::ChannelSend { channel, value, .. } => {
                // Simplified: treat as method call
                format!(
                    "{}.send({})",
                    self.generate_expression(channel),
                    self.generate_expression(value)
                )
            }

            Expression::ChannelRecv { channel, .. } => {
                format!("{}.receive()", self.generate_expression(channel))
            }

            Expression::Block { statements, .. } => {
                let mut output = String::from("(() => {\n");
                self.indent_level += 1;
                for stmt in statements {
                    output.push_str(&self.generate_statement(stmt));
                }
                self.indent_level -= 1;
                output.push_str(&self.indent());
                output.push_str("})()");
                output
            }
        }
    }

    fn generate_literal(&self, lit: &Literal) -> String {
        match lit {
            Literal::Int(n) => n.to_string(),
            Literal::Float(f) => f.to_string(),
            Literal::String(s) => {
                // Check for string interpolation markers (${ or just $ with identifier)
                if s.contains("${") || s.contains("$") {
                    // Use template literal with backticks for interpolation
                    format!("`{}`", s)
                } else {
                    // Use single quotes for plain strings
                    format!("'{}'", s.replace('\'', "\\'"))
                }
            }
            Literal::Char(c) => format!("'{}'", c),
            Literal::Bool(b) => b.to_string(),
        }
    }

    fn generate_pattern_match(&self, pattern: &Pattern, match_value: &str) -> String {
        match pattern {
            Pattern::Wildcard => "true".to_string(),
            Pattern::Identifier(id) => {
                // Bind the variable: `((id = __match_value) !== undefined || true)` ensures
                // the variable is assigned AND the condition is always true (catch-all binding).
                // We use `var` here since `let` cannot be used inside an expression.
                format!("((({} = {}) !== undefined) || true)", id, match_value)
            }
            Pattern::Reference(inner) => {
                // JavaScript doesn't have references, just match the inner pattern
                self.generate_pattern_match(inner, match_value)
            }
            Pattern::Literal(lit) => format!("{} === {}", match_value, self.generate_literal(lit)),
            Pattern::EnumVariant(name, binding) => {
                use crate::parser::EnumPatternBinding;
                // Convert :: to . for JS: Color::Red → Color.Red
                let js_name = name.replace("::", ".");
                match binding {
                    EnumPatternBinding::Wildcard | EnumPatternBinding::None => {
                        format!("{} === {}", match_value, js_name)
                    }
                    EnumPatternBinding::Single(var) => {
                        // Enum with data: extract the inner value
                        format!(
                            "({}.type === '{}' && (({} = {}.value) !== undefined || true))",
                            match_value, js_name, var, match_value
                        )
                    }
                    EnumPatternBinding::Tuple(patterns) => {
                        let mut conditions =
                            vec![format!("{}.type === '{}'", match_value, js_name)];
                        for (i, pat) in patterns.iter().enumerate() {
                            if let Pattern::Identifier(bind) = pat {
                                conditions.push(format!(
                                    "(({} = {}.value[{}]) !== undefined || true)",
                                    bind, match_value, i
                                ));
                            }
                        }
                        format!("({})", conditions.join(" && "))
                    }
                    _ => format!("{} === {}", match_value, js_name),
                }
            }
            Pattern::Or(patterns) => {
                let conditions: Vec<String> = patterns
                    .iter()
                    .map(|p| self.generate_pattern_match(p, match_value))
                    .collect();
                format!("({})", conditions.join(" || "))
            }
            Pattern::Tuple(_) => format!("Array.isArray({})", match_value),
        }
    }

    fn binary_op_to_js(&self, op: &BinaryOp) -> String {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Sub => "-",
            BinaryOp::Mul => "*",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::Eq => "===",
            BinaryOp::Ne => "!==",
            BinaryOp::Lt => "<",
            BinaryOp::Le => "<=",
            BinaryOp::Gt => ">",
            BinaryOp::Ge => ">=",
            BinaryOp::And => "&&",
            BinaryOp::Or => "||",
            BinaryOp::BitAnd => "&",
            BinaryOp::BitOr => "|",
            BinaryOp::BitXor => "^",
            BinaryOp::Shl => "<<",
            BinaryOp::Shr => ">>",
        }
        .to_string()
    }

    fn unary_op_to_js(&self, op: &UnaryOp) -> String {
        match op {
            UnaryOp::Not => "!".to_string(),
            UnaryOp::Neg => "-".to_string(),
            UnaryOp::Ref => "".to_string(), // & doesn't apply in JS (auto-reference)
            UnaryOp::MutRef => "".to_string(), // &mut doesn't apply in JS (auto-reference)
            UnaryOp::Deref => "".to_string(), // * doesn't apply in JS
        }
    }

    fn type_to_jsdoc(ty: &Type) -> String {
        match ty {
            Type::Int | Type::Int32 | Type::Uint | Type::Float => "number".to_string(),
            Type::String => "string".to_string(),
            Type::Bool => "boolean".to_string(),
            Type::Custom(name) => name.clone(),
            Type::Generic(name) => name.clone(),
            Type::Vec(inner) => format!("Array<{}>", Self::type_to_jsdoc(inner)),
            Type::Option(inner) => format!("{}|null", Self::type_to_jsdoc(inner)),
            _ => "any".to_string(),
        }
    }

    /// Generate console.log with format string support: println("{}", x) → console.log(`${x}`)
    fn generate_js_println(&self, args: &[String]) -> String {
        if args.is_empty() {
            return "console.log()".to_string();
        }
        // Check if first arg is a format string (quoted)
        let first = &args[0];
        if first.starts_with('\'') || first.starts_with('"') {
            let unquoted = &first[1..first.len() - 1];
            if unquoted.contains("{}") && args.len() > 1 {
                // Convert {} placeholders to template literal ${} syntax
                let mut template = unquoted.to_string();
                for arg in &args[1..] {
                    template = template.replacen("{}", &format!("${{{}}}", arg), 1);
                }
                return format!("console.log(`{}`)", template);
            }
        }
        format!("console.log({})", args.join(", "))
    }

    /// Generate console.log without newline (JS doesn't have print without newline easily)
    fn generate_js_print(&self, args: &[String]) -> String {
        if args.is_empty() {
            return "process.stdout.write('')".to_string();
        }
        let first = &args[0];
        if first.starts_with('\'') || first.starts_with('"') {
            let unquoted = &first[1..first.len() - 1];
            if unquoted.contains("{}") && args.len() > 1 {
                let mut template = unquoted.to_string();
                for arg in &args[1..] {
                    template = template.replacen("{}", &format!("${{{}}}", arg), 1);
                }
                return format!("process.stdout.write(`{}`)", template);
            }
        }
        format!("process.stdout.write(String({}))", args.join(" + "))
    }

    fn indent(&self) -> String {
        "    ".repeat(self.indent_level)
    }

    fn generate_pattern(&self, pattern: &Pattern) -> String {
        match pattern {
            Pattern::Wildcard => "_".to_string(),
            Pattern::Identifier(name) => name.clone(),
            Pattern::Tuple(patterns) => {
                let pattern_strs: Vec<String> =
                    patterns.iter().map(|p| self.generate_pattern(p)).collect();
                format!("[{}]", pattern_strs.join(", "))
            }
            Pattern::Reference(inner) => self.generate_pattern(inner), // JS doesn't have references
            Pattern::EnumVariant(name, _) => name.clone(),             // Simplified for JS
            Pattern::Literal(lit) => self.generate_literal(lit),
            Pattern::Or(_) => "_".to_string(), // Simplified for JS
        }
    }
}

impl Default for JavaScriptGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_empty_program() {
        let mut gen = JavaScriptGenerator::new();
        let program = Program { items: vec![] };
        let code = gen.generate(&program);
        assert!(code.contains("Windjammer JavaScript transpiler"));
    }

    #[test]
    fn test_generate_simple_function() {
        let mut gen = JavaScriptGenerator::new();
        let program = Program {
            items: vec![Item::Function {
                decl: FunctionDecl {
                    name: "greet".to_string(),
                    is_pub: false,
                    is_extern: false,
                    parameters: vec![],
                    return_type: None,
                    body: vec![],
                    decorators: vec![],
                    is_async: false,
                    type_params: vec![],
                    where_clause: vec![],
                    parent_type: None,
                    doc_comment: None,
                },
                location: None,
            }],
        };

        let code = gen.generate(&program);
        assert!(code.contains("export function greet"));
    }

    #[test]
    fn test_generate_literal() {
        let gen = JavaScriptGenerator::new();
        assert_eq!(gen.generate_literal(&Literal::Int(42)), "42");
        assert_eq!(
            gen.generate_literal(&Literal::String("hello".to_string())),
            "'hello'"
        );
        assert_eq!(gen.generate_literal(&Literal::Bool(true)), "true");
    }

    #[test]
    fn test_binary_op_conversion() {
        let gen = JavaScriptGenerator::new();
        assert_eq!(gen.binary_op_to_js(&BinaryOp::Eq), "===");
        assert_eq!(gen.binary_op_to_js(&BinaryOp::Ne), "!==");
        assert_eq!(gen.binary_op_to_js(&BinaryOp::And), "&&");
        assert_eq!(gen.binary_op_to_js(&BinaryOp::Add), "+");
    }
}
