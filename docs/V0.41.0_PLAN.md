# Windjammer v0.41.0 Plan: Compiler Improvements + Go Backend

**Branch:** `feature/v0.41.0-compiler-improvements`  
**Previous Release:** `v0.40.0`  
**Status:** In Progress

---

## Goals

v0.41.0 focuses on two tracks:

1. **Compiler Correctness & DX** — Making the compiler smarter and error messages better
2. **Go Backend (Experimental)** — First steps toward a second compilation target for fast iteration

---

## Track 1: Compiler Improvements

### 1.1 Compiler-Side Immutability Enforcement
**Priority:** HIGH  
**Status:** [ ] Not Started

Currently, mutating a `let` binding only produces an error from `rustc` (E0384). The Windjammer compiler should emit its own error with context-aware suggestions **before** Rust compilation.

**Tasks:**
- [ ] Detect mutation of `let` bindings in the analyzer (direct assignment, compound assignment, field mutation, method calls)
- [ ] Emit Windjammer-native error: `"Cannot mutate immutable binding 'x'. Did you mean 'let mut x'?"`
- [ ] Include source location (line, column) in error message
- [ ] Add TDD tests for all mutation patterns
- [ ] Verify game engine code still compiles cleanly

### 1.2 Automatic For-Loop Borrow Inference
**Priority:** HIGH  
**Status:** [ ] Not Started

Users currently must write `for item in &collection` to iterate by reference. The compiler should infer this automatically when the collection is used after the loop.

**Tasks:**
- [ ] Detect when a `for` loop iterates a non-Copy collection
- [ ] Check if the collection is used after the loop
- [ ] If used after: auto-insert `&` (borrow) or `&mut` (if loop body mutates)
- [ ] If not used after: allow move (consume the collection)
- [ ] Handle `for item in &mut collection` for mutation patterns
- [ ] Add TDD tests for all loop borrow patterns
- [ ] Dogfood against game engine code

### 1.3 Ownership Inference for Field Moves
**Priority:** MEDIUM  
**Status:** [ ] Not Started

Known issue from v0.40.0: the compiler infers `&self` when a method returns a non-Copy field (which requires owned `self` to move the field out).

**Tasks:**
- [ ] Detect return expressions that move non-Copy fields from `self`
- [ ] Infer owned `self` when a field is moved out
- [ ] Handle partial moves (moving one field while borrowing another)
- [ ] Un-ignore `test_trait_impl_self_param_owned` test
- [ ] Add comprehensive TDD tests

### 1.4 Enhanced Error Messages with Context-Aware Suggestions
**Priority:** MEDIUM  
**Status:** [ ] Not Started

Compiler errors should suggest fixes, not just report problems.

**Tasks:**
- [ ] Add "did you mean?" suggestions for misspelled identifiers
- [ ] Add "try adding `mut`" suggestions for immutability errors
- [ ] Add "try adding `.clone()`" suggestions for move errors
- [ ] Add "consider using `&`" suggestions for ownership errors
- [ ] Format errors with source context (show the offending line with caret)

### 1.5 Enhanced Auto-Conversion Heuristics
**Priority:** MEDIUM  
**Status:** [ ] Not Started

Improve automatic type conversions to reduce boilerplate.

**Tasks:**
- [ ] Auto-convert `&str` to `String` when passing to owned parameter
- [ ] Auto-convert integer types (i32 → i64) where safe
- [ ] Auto-convert `&T` to `T` for Copy types
- [ ] Detect and suggest `.to_string()` / `.as_str()` where needed
- [ ] Add TDD tests for all conversion patterns

### 1.6 Lifetime Inference Improvements
**Priority:** LOW (foundational for future)  
**Status:** [ ] Not Started

Begin laying groundwork for lifetime inference beyond the current scope-based approach.

**Tasks:**
- [ ] Audit current lifetime handling (where do we rely on Rust's inference?)
- [ ] Identify patterns where explicit lifetimes would be needed
- [ ] Document lifetime inference strategy
- [ ] Implement basic lifetime elision rules in the analyzer

---

## Track 2: Go Backend (Experimental)

> Full design document: [GO_BACKEND_PLAN.md](GO_BACKEND_PLAN.md)

The Go backend is a **semantically-equivalent alternative compilation target**. Safety is enforced by the Windjammer analyzer at compile time, before any backend runs. The Go backend provides sub-second compilation for rapid development iteration.

### 2.1 Phase 0: Formalize Semantic Contract
**Priority:** HIGH (prerequisite for Go backend)  
**Status:** [ ] Not Started

**Tasks:**
- [ ] Audit Rust codegen for safety checks that should be in the analyzer
- [ ] Lift use-after-move detection to analyzer (verify completeness)
- [ ] Lift mutation tracking to analyzer (verify completeness)
- [ ] Lift exhaustiveness checking to analyzer
- [ ] Create initial conformance test suite (10-20 backend-independent tests)
- [ ] Write `WINDJAMMER_SEMANTIC_CONTRACT.md`

### 2.2 Phase 1: Go Backend Scaffold
**Priority:** HIGH  
**Status:** [ ] Not Started

**Tasks:**
- [ ] Add `Target::Go` to the `CompilationTarget` enum
- [ ] Create `codegen/go/mod.rs` implementing `CodegenBackend`
- [ ] Implement basic type mapping (primitives, string)
- [ ] Implement function generation (parameters, return types, bodies)
- [ ] Implement `let`/`let mut` bindings, assignments, return statements
- [ ] Implement basic expressions (literals, identifiers, binary ops, unary ops)
- [ ] Generate `go.mod` and `main.go`
- [ ] Wire into CLI: `wj build --target go`
- [ ] Run `go build` on generated code
- [ ] First conformance test passing on both Rust and Go backends

### 2.3 Phase 2: Structs and Methods
**Priority:** MEDIUM  
**Status:** [ ] Not Started

**Tasks:**
- [ ] Struct declaration → Go struct (with capitalized field names)
- [ ] Struct literal construction
- [ ] Field access (snake_case → CamelCase mapping)
- [ ] Impl blocks → Go methods (receiver functions)
- [ ] Self parameter → Go receiver (value or pointer based on mutation analysis)
- [ ] Method call generation

### 2.4 Phase 3: Enums and Pattern Matching
**Priority:** MEDIUM  
**Status:** [ ] Not Started

**Tasks:**
- [ ] Enum → Go interface + concrete structs
- [ ] Simple pattern matching → type switch
- [ ] Nested pattern matching → nested type assertions
- [ ] Pattern bindings (extracting fields)
- [ ] Match guards → if conditions in cases
- [ ] Exhaustiveness → `default: panic("unreachable")`

### 2.5 Phase 4+: Traits, Generics, Stdlib, Closures
**Priority:** LOW (future phases)  
**Status:** [ ] Not Started

See [GO_BACKEND_PLAN.md](GO_BACKEND_PLAN.md) Phases 4-7 for full details.

---

## Future: Rust + Go Interop (Research)

A longer-term vision where Windjammer programs can target **both** Rust and Go simultaneously, with the compiler generating IPC stubs at the boundary:

- Performance-critical code (rendering, physics) → Rust
- Rapid-iteration code (game logic, UI, networking) → Go
- Communication via Unix domain sockets, gRPC, or shared memory
- Compiler auto-determines optimal placement based on usage analysis

This is a research direction, not a v0.41.0 deliverable. See discussion in the development log.

---

## Success Criteria for v0.41.0

- [ ] Windjammer compiler emits its own immutability errors (not just rustc)
- [ ] `for item in collection` works without explicit `&` when collection is reused
- [ ] Owned self correctly inferred for non-Copy field moves
- [ ] At least 5 new context-aware error message suggestions
- [ ] Go backend compiles "Hello, World" and basic struct programs
- [ ] First conformance test passes on both Rust and Go backends
- [ ] Game engine (windjammer-game) error count continues to decrease

---

## Development Methodology

Same as v0.40.0: **TDD + Dogfooding**

```
1. DISCOVER → Compile real game code or identify compiler gap
2. REPRODUCE → Create minimal test case (failing)
3. FIX → Implement proper solution
4. VERIFY → Test passes + game errors reduce
5. COMMIT → Document what was fixed and why
6. REPEAT
```

No workarounds. No tech debt. Only proper fixes.
