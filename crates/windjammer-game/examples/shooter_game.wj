// Note: This is a conceptual example showing Windjammer UI syntax
// In a real application, types would be imported from windjammer_ui

// Space Shooter Game Example


@derive(Debug, Clone)
struct Player {
    position: Vec2,
    velocity: Vec2,
    health: int,
    score: int,
}

@derive(Debug, Clone)
struct Enemy {
    position: Vec2,
    velocity: Vec2,
    health: int,
}

@derive(Debug, Clone)
struct Bullet {
    position: Vec2,
    velocity: Vec2,
    from_player: bool,
}

@game
struct ShooterGame {
    player: Player,
    enemies: [Enemy],
    bullets: [Bullet],
    game_time: f32,
    spawn_timer: f32,
    game_over: bool,
}

impl ShooterGame {
    fn new() -> ShooterGame {
        ShooterGame {
            player: Player {
                position: Vec2::new(400.0, 550.0),
                velocity: Vec2::ZERO,
                health: 100,
                score: 0,
            },
            enemies: [],
            bullets: [],
            game_time: 0.0,
            spawn_timer: 0.0,
            game_over: false,
        }
    }

    fn shoot() {
        bullets.push(Bullet {
            position: Vec2::new(player.position.x, player.position.y - 20.0),
            velocity: Vec2::new(0.0, -500.0),  // Upward
            from_player: true,
        })
    }

    fn spawn_enemy() {
        let x = (game_time * 137.5) % 750.0 + 25.0  // Pseudo-random x
        enemies.push(Enemy {
            position: Vec2::new(x, 50.0),
            velocity: Vec2::new(0.0, 100.0),  // Downward
            health: 50,
        })
    }
}

impl GameLoop for ShooterGame {
    fn update(delta: f32) {
        if game_over {
            return
        }

        game_time += delta
        spawn_timer += delta

        // Spawn enemies every 2 seconds
        if spawn_timer >= 2.0 {
            spawn_enemy()
            spawn_timer = 0.0
        }

        // Update player
        player.position.x += player.velocity.x * delta
        player.position.x = player.position.x.clamp(0.0, 800.0)

        // Update enemies
        for enemy in enemies {
            enemy.position.y += enemy.velocity.y * delta
        }

        // Update bullets
        for bullet in bullets {
            bullet.position.y += bullet.velocity.y * delta
        }

        // Check bullet-enemy collisions
        let mut bullets_to_remove = []
        let mut enemies_to_remove = []

        for (b_idx, bullet) in bullets.enumerate() {
            if !bullet.from_player {
                continue
            }

            for (e_idx, enemy) in enemies.enumerate() {
                let dx = bullet.position.x - enemy.position.x
                let dy = bullet.position.y - enemy.position.y
                let distance = (dx * dx + dy * dy).sqrt()

                if distance < 30.0 {
                    // Hit!
                    enemy.health -= 25
                    bullets_to_remove.push(b_idx)

                    if enemy.health <= 0 {
                        enemies_to_remove.push(e_idx)
                        player.score += 100
                    }
                    break
                }
            }
        }

        // Remove dead enemies (reverse order to preserve indices)
        for idx in enemies_to_remove.reversed() {
            enemies.remove(idx)
        }

        // Remove used bullets
        for idx in bullets_to_remove.reversed() {
            bullets.remove(idx)
        }

        // Remove off-screen bullets
        bullets = bullets.filter(|b| b.position.y > -50.0 && b.position.y < 650.0)

        // Enemies that reach bottom damage player
        let enemies_at_bottom = enemies.filter(|e| e.position.y > 560.0).len()
        if enemies_at_bottom > 0 {
            player.health -= enemies_at_bottom * 10
        }

        // Remove enemies at bottom
        enemies = enemies.filter(|e| e.position.y <= 560.0)

        // Game over check
        if player.health <= 0 {
            game_over = true
        }
    }

    fn render(ctx: RenderContext) {
        ctx.clear(Color::BLACK)

        // Render player
        ctx.draw_rect(
            player.position.x - 20.0,
            player.position.y - 20.0,
            40.0, 40.0,
            Color::GREEN
        )

        // Render enemies
        for enemy in enemies {
            ctx.draw_rect(
                enemy.position.x - 15.0,
                enemy.position.y - 15.0,
                30.0, 30.0,
                Color::RED
            )
        }

        // Render bullets
        for bullet in bullets {
            let color = if bullet.from_player { Color::GREEN } else { Color::RED }
            ctx.draw_circle(bullet.position.x, bullet.position.y, 5.0, color)
        }

        // Render UI
        ctx.draw_text("Score: {player.score}", 10.0, 30.0, Color::WHITE)
        ctx.draw_text("Health: {player.health}", 10.0, 60.0, Color::WHITE)
        ctx.draw_text("Enemies: {enemies.len()}", 10.0, 90.0, Color::WHITE)

        if game_over {
            ctx.draw_text(
                "GAME OVER! Final Score: {player.score}",
                200.0, 300.0,
                Color::RED
            )
        }
    }
}

fn main() {
    print("ðŸš€ Space Shooter Game Example")
    print("==============================\n")

    let mut game = ShooterGame::new()
    let ctx = RenderContext::new()

    print("Starting game simulation...\n")

    // Simulate game loop
    for frame in 0..180 {  // 3 seconds at 60 FPS
        let delta = 1.0 / 60.0

        // Simulate shooting every 20 frames
        if frame % 20 == 0 {
            game.shoot()
            print("Frame {frame}: Player shoots! Bullets: {game.bullets.len()}")
        }

        game.update(delta)
        game.render(ctx)

        // Print stats every 60 frames (1 second)
        if frame % 60 == 0 {
            print("Time: {game.game_time:.1}s | Score: {game.player.score} | Health: {game.player.health} | Enemies: {game.enemies.len()} | Bullets: {game.bullets.len()}")
        }

        if game.game_over {
            print("\nðŸ’€ Game Over!")
            print("Final Score: {game.player.score}")
            print("Survived: {game.game_time:.1} seconds")
            break
        }
    }

    if !game.game_over {
        print("\nâœ… Simulation complete!")
        print("Final Score: {game.player.score}")
        print("Health Remaining: {game.player.health}")
    }

    print("\nðŸŽ¯ Key Features Demonstrated:")
    print("  - Entity management (player, enemies, bullets)")
    print("  - Collision detection")
    print("  - Spawning system")
    print("  - Score tracking")
    print("  - Health system")
    print("  - Game over condition")
}

