// 2048-style Puzzle Game Example

use windjammer_ui.game.*

@derive(Debug, Clone, Copy, PartialEq, Eq)
enum Direction {
    Up,
    Down,
    Left,
    Right
}

@game
struct PuzzleGame {
    grid: [[int; 4]; 4]
    score: int
    moves: int
    game_over: bool
}

impl PuzzleGame {
    fn new() -> PuzzleGame {
        let mut game = PuzzleGame {
            grid: [[0; 4]; 4],
            score: 0,
            moves: 0,
            game_over: false
        }
        game.spawn_tile()
        game.spawn_tile()
        game
    }

    fn spawn_tile() {
        // Find empty cells
        let mut empty_cells = []
        for row in 0..4 {
            for col in 0..4 {
                if grid[row][col] == 0 {
                    empty_cells.push((row, col))
                }
            }
        }

        if !empty_cells.is_empty() {
            // Spawn a 2 or 4 (90% chance of 2)
            let value = if moves % 10 == 0 { 4 } else { 2 }
            let idx = (moves * 17) % empty_cells.len()  // Pseudo-random
            let (row, col) = empty_cells[idx]
            grid[row][col] = value
        }
    }

    fn move_tiles(direction: Direction) {
        let old_grid = grid

        match direction {
            Direction::Left => move_left(),
            Direction::Right => move_right(),
            Direction::Up => move_up(),
            Direction::Down => move_down()
        }

        // If grid changed, spawn new tile and increment moves
        if old_grid != grid {
            moves += 1
            spawn_tile()
            check_game_over()
        }
    }

    fn move_left() {
        for row in 0..4 {
            let mut merged = [false; 4]
            for _ in 0..3 {
                for col in 0..3 {
                    if grid[row][col] == 0 && grid[row][col + 1] != 0 {
                        // Slide tile
                        grid[row][col] = grid[row][col + 1]
                        grid[row][col + 1] = 0
                    } else if grid[row][col] == grid[row][col + 1] &&
                              grid[row][col] != 0 && !merged[col] {
                        // Merge tiles
                        grid[row][col] *= 2
                        score += grid[row][col]
                        grid[row][col + 1] = 0
                        merged[col] = true
                    }
                }
            }
        }
    }

    fn move_right() {
        for row in 0..4 {
            let mut merged = [false; 4]
            for _ in 0..3 {
                for col in (1..4).reversed() {
                    if grid[row][col] == 0 && grid[row][col - 1] != 0 {
                        grid[row][col] = grid[row][col - 1]
                        grid[row][col - 1] = 0
                    } else if grid[row][col] == grid[row][col - 1] &&
                              grid[row][col] != 0 && !merged[col] {
                        grid[row][col] *= 2
                        score += grid[row][col]
                        grid[row][col - 1] = 0
                        merged[col] = true
                    }
                }
            }
        }
    }

    fn move_up() {
        for col in 0..4 {
            let mut merged = [false; 4]
            for _ in 0..3 {
                for row in 0..3 {
                    if grid[row][col] == 0 && grid[row + 1][col] != 0 {
                        grid[row][col] = grid[row + 1][col]
                        grid[row + 1][col] = 0
                    } else if grid[row][col] == grid[row + 1][col] &&
                              grid[row][col] != 0 && !merged[row] {
                        grid[row][col] *= 2
                        score += grid[row][col]
                        grid[row + 1][col] = 0
                        merged[row] = true
                    }
                }
            }
        }
    }

    fn move_down() {
        for col in 0..4 {
            let mut merged = [false; 4]
            for _ in 0..3 {
                for row in (1..4).reversed() {
                    if grid[row][col] == 0 && grid[row - 1][col] != 0 {
                        grid[row][col] = grid[row - 1][col]
                        grid[row - 1][col] = 0
                    } else if grid[row][col] == grid[row - 1][col] &&
                              grid[row][col] != 0 && !merged[row] {
                        grid[row][col] *= 2
                        score += grid[row][col]
                        grid[row - 1][col] = 0
                        merged[row] = true
                    }
                }
            }
        }
    }

    fn check_game_over() {
        // Check if any moves are possible
        for row in 0..4 {
            for col in 0..4 {
                if grid[row][col] == 0 {
                    return  // Empty cell exists
                }

                // Check adjacent cells for possible merges
                if col < 3 && grid[row][col] == grid[row][col + 1] {
                    return
                }
                if row < 3 && grid[row][col] == grid[row + 1][col] {
                    return
                }
            }
        }

        game_over = true
    }

    fn get_max_tile() -> int {
        let mut max = 0
        for row in grid {
            for cell in row {
                if cell > max {
                    max = cell
                }
            }
        }
        max
    }

    fn get_tile_color(value: int) -> Color {
        match value {
            0 => Color::new(205, 193, 180),
            2 => Color::new(238, 228, 218),
            4 => Color::new(237, 224, 200),
            8 => Color::new(242, 177, 121),
            16 => Color::new(245, 149, 99),
            32 => Color::new(246, 124, 95),
            64 => Color::new(246, 94, 59),
            128 => Color::new(237, 207, 114),
            256 => Color::new(237, 204, 97),
            512 => Color::new(237, 200, 80),
            1024 => Color::new(237, 197, 63),
            2048 => Color::new(237, 194, 46),
            _ => Color::new(60, 58, 50)
        }
    }

    fn display() -> string {
        let mut result = "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
        for row in grid {
            result += "â”‚"
            for cell in row {
                if cell == 0 {
                    result += "    ."
                } else {
                    result += " {cell:4}"
                }
            }
            result += "â”‚\n"
        }
        result += "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n"
        result += "Score: {score} | Moves: {moves}\n"
        result
    }
}

impl GameLoop for PuzzleGame {
    fn update(delta: f32) {
        // Game logic handled by move_tiles
    }

    fn render(ctx: RenderContext) {
        ctx.clear(Color::new(187, 173, 160))  // Background

        let tile_size = 100.0
        let padding = 10.0
        let offset_x = 50.0
        let offset_y = 100.0

        // Render grid
        for row in 0..4 {
            for col in 0..4 {
                let x = offset_x + (col as f32) * (tile_size + padding)
                let y = offset_y + (row as f32) * (tile_size + padding)

                let value = grid[row][col]
                let color = get_tile_color(value)

                ctx.draw_rect(x, y, tile_size, tile_size, color)

                if value > 0 {
                    ctx.draw_text(
                        "{value}",
                        x + tile_size / 2.0 - 20.0,
                        y + tile_size / 2.0 + 10.0,
                        Color::WHITE
                    )
                }
            }
        }

        // Render UI
        ctx.draw_text("Score: {score}", 50.0, 50.0, Color::WHITE)
        ctx.draw_text("Moves: {moves}", 300.0, 50.0, Color::WHITE)
        ctx.draw_text("Max Tile: {get_max_tile()}", 550.0, 50.0, Color::WHITE)

        if game_over {
            ctx.draw_text("GAME OVER!", 200.0, 600.0, Color::RED)
        }
    }
}

fn main() {
    print("ðŸ§© 2048-Style Puzzle Game Example")
    print("==================================\n")

    let mut game = PuzzleGame::new()
    let ctx = RenderContext::new()

    print("Initial state:")
    print(game.display())

    // Simulate some moves
    let moves = [
        Direction::Left,
        Direction::Up,
        Direction::Right,
        Direction::Down,
        Direction::Left,
        Direction::Left,
        Direction::Up,
        Direction::Right
    ]

    for (i, direction) in moves.enumerate() {
        print("Move {i + 1}: {direction}")
        game.move_tiles(direction)
        game.render(ctx)
        print(game.display())

        if game.game_over {
            print("ðŸ’€ Game Over!")
            break
        }
    }

    print("\nðŸ“Š Final Statistics:")
    print("  Score: {game.score}")
    print("  Moves: {game.moves}")
    print("  Max Tile: {game.get_max_tile()}")

    print("\nðŸŽ¯ Key Features Demonstrated:")
    print("  - 4x4 grid management")
    print("  - Tile movement and merging logic")
    print("  - Score calculation")
    print("  - Game over detection")
    print("  - Visual rendering with colors")
    print("  - State persistence")
}

