// std/collections - Collection types (HashMap, HashSet, etc.)
// Wraps Rust's std::collections with Windjammer-friendly APIs

use std.collections.HashMap as RustHashMap
use std.collections.HashSet as RustHashSet
use std.collections.BTreeMap as RustBTreeMap
use std.collections.BTreeSet as RustBTreeSet
use std.collections.VecDeque as RustVecDeque

// HashMap - Hash table implementation
pub struct HashMap<K, V> {
    inner: RustHashMap<K, V>
}

impl<K, V> HashMap<K, V> {
    pub fn new() -> Self {
        HashMap { inner: RustHashMap::new() }
    }
    
    pub fn with_capacity(capacity: int) -> Self {
        HashMap { inner: RustHashMap::with_capacity(capacity as usize) }
    }
    
    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
        self.inner.insert(key, value)
    }
    
    pub fn get(&self, key: &K) -> Option<&V> {
        self.inner.get(key)
    }
    
    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {
        self.inner.get_mut(key)
    }
    
    pub fn remove(&mut self, key: &K) -> Option<V> {
        self.inner.remove(key)
    }
    
    pub fn contains_key(&self, key: &K) -> bool {
        self.inner.contains_key(key)
    }
    
    pub fn len(&self) -> int {
        self.inner.len() as i64
    }
    
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }
    
    pub fn clear(&mut self) {
        self.inner.clear()
    }
}

// HashSet - Hash set implementation
pub struct HashSet<T> {
    inner: RustHashSet<T>
}

impl<T> HashSet<T> {
    pub fn new() -> Self {
        HashSet { inner: RustHashSet::new() }
    }
    
    pub fn with_capacity(capacity: int) -> Self {
        HashSet { inner: RustHashSet::with_capacity(capacity as usize) }
    }
    
    pub fn insert(&mut self, value: T) -> bool {
        self.inner.insert(value)
    }
    
    pub fn remove(&mut self, value: &T) -> bool {
        self.inner.remove(value)
    }
    
    pub fn contains(&self, value: &T) -> bool {
        self.inner.contains(value)
    }
    
    pub fn len(&self) -> int {
        self.inner.len() as i64
    }
    
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }
    
    pub fn clear(&mut self) {
        self.inner.clear()
    }
}

// BTreeMap - Sorted map implementation
pub struct BTreeMap<K, V> {
    inner: RustBTreeMap<K, V>
}

impl<K, V> BTreeMap<K, V> {
    pub fn new() -> Self {
        BTreeMap { inner: RustBTreeMap::new() }
    }
    
    pub fn insert(&mut self, key: K, value: V) -> Option<V> {
        self.inner.insert(key, value)
    }
    
    pub fn get(&self, key: &K) -> Option<&V> {
        self.inner.get(key)
    }
    
    pub fn remove(&mut self, key: &K) -> Option<V> {
        self.inner.remove(key)
    }
    
    pub fn contains_key(&self, key: &K) -> bool {
        self.inner.contains_key(key)
    }
    
    pub fn len(&self) -> int {
        self.inner.len() as i64
    }
    
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }
}

// BTreeSet - Sorted set implementation
pub struct BTreeSet<T> {
    inner: RustBTreeSet<T>
}

impl<T> BTreeSet<T> {
    pub fn new() -> Self {
        BTreeSet { inner: RustBTreeSet::new() }
    }
    
    pub fn insert(&mut self, value: T) -> bool {
        self.inner.insert(value)
    }
    
    pub fn remove(&mut self, value: &T) -> bool {
        self.inner.remove(value)
    }
    
    pub fn contains(&self, value: &T) -> bool {
        self.inner.contains(value)
    }
    
    pub fn len(&self) -> int {
        self.inner.len() as i64
    }
    
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }
}

// VecDeque - Double-ended queue
pub struct VecDeque<T> {
    inner: RustVecDeque<T>
}

impl<T> VecDeque<T> {
    pub fn new() -> Self {
        VecDeque { inner: RustVecDeque::new() }
    }
    
    pub fn with_capacity(capacity: int) -> Self {
        VecDeque { inner: RustVecDeque::with_capacity(capacity as usize) }
    }
    
    pub fn push_front(&mut self, value: T) {
        self.inner.push_front(value)
    }
    
    pub fn push_back(&mut self, value: T) {
        self.inner.push_back(value)
    }
    
    pub fn pop_front(&mut self) -> Option<T> {
        self.inner.pop_front()
    }
    
    pub fn pop_back(&mut self) -> Option<T> {
        self.inner.pop_back()
    }
    
    pub fn len(&self) -> int {
        self.inner.len() as i64
    }
    
    pub fn is_empty(&self) -> bool {
        self.inner.is_empty()
    }
    
    pub fn clear(&mut self) {
        self.inner.clear()
    }
}

