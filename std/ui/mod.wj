// Windjammer UI Standard Library
// Pure Windjammer API for building UIs - no Rust, no JavaScript, no Tauri
//
// IMPORTANT: This file contains TYPE DEFINITIONS ONLY.
// No implementation here - the Windjammer compiler generates Rust code
// that uses the windjammer-ui crate (which is pre-compiled).
//
// This avoids circular dependencies:
// - Compiler doesn't depend on windjammer-ui
// - Stdlib doesn't depend on windjammer-ui  
// - Generated code depends on windjammer-ui (correct!)
//
// The compiler knows how to translate these types to windjammer-ui calls.

// Core UI types
pub struct Button {
    label: string,
    variant: ButtonVariant,
    on_click: fn(),
}

pub enum ButtonVariant {
    Primary,
    Secondary,
    Danger,
    Ghost,
}

impl Button {
    pub fn new(label: string) -> Button {
        Button {
            label: label,
            variant: ButtonVariant::Primary,
            on_click: || {},
        }
    }
    
    pub fn variant(self, variant: ButtonVariant) -> Button {
        self.variant = variant
        self
    }
    
    pub fn on_click(self, handler: fn()) -> Button {
        self.on_click = handler
        self
    }
}

// Container for layout
pub struct Container {
    children: Vec<UIElement>,
    max_width: string,
    padding: string,
}

impl Container {
    pub fn new() -> Container {
        Container {
            children: Vec::new(),
            max_width: "100%",
            padding: "16px",
        }
    }
    
    pub fn child(self, child: UIElement) -> Container {
        self.children.push(child)
        self
    }
    
    pub fn max_width(self, width: string) -> Container {
        self.max_width = width
        self
    }
}

// Code Editor
pub struct CodeEditor {
    content: string,
    language: string,
    theme: string,
    on_change: fn(string),
}

impl CodeEditor {
    pub fn new(content: string) -> CodeEditor {
        CodeEditor {
            content: content,
            language: "windjammer",
            theme: "vs-dark",
            on_change: |_| {},
        }
    }
    
    pub fn language(self, lang: string) -> CodeEditor {
        self.language = lang
        self
    }
    
    pub fn on_change(self, handler: fn(string)) -> CodeEditor {
        self.on_change = handler
        self
    }
}

// File Tree
pub struct FileTree {
    root: FileNode,
    on_select: fn(string),
}

pub struct FileNode {
    name: string,
    path: string,
    is_directory: bool,
    children: Vec<FileNode>,
}

impl FileNode {
    pub fn new(name: string, path: string, is_directory: bool) -> FileNode {
        FileNode {
            name: name,
            path: path,
            is_directory: is_directory,
            children: Vec::new(),
        }
    }
    
    pub fn add_child(self, child: FileNode) -> FileNode {
        self.children.push(child)
        self
    }
}

impl FileTree {
    pub fn new(root: FileNode) -> FileTree {
        FileTree {
            root: root,
            on_select: |_| {},
        }
    }
    
    pub fn on_select(self, handler: fn(string)) -> FileTree {
        self.on_select = handler
        self
    }
}

// Input
pub struct Input {
    value: string,
    placeholder: string,
    on_change: fn(string),
}

impl Input {
    pub fn new() -> Input {
        Input {
            value: "",
            placeholder: "",
            on_change: |_| {},
        }
    }
    
    pub fn placeholder(self, text: string) -> Input {
        self.placeholder = text
        self
    }
    
    pub fn on_change(self, handler: fn(string)) -> Input {
        self.on_change = handler
        self
    }
}

// Text
pub struct Text {
    content: string,
    size: TextSize,
    weight: TextWeight,
}

pub enum TextSize {
    Small,
    Medium,
    Large,
    XLarge,
}

pub enum TextWeight {
    Normal,
    Bold,
}

impl Text {
    pub fn new(content: string) -> Text {
        Text {
            content: content,
            size: TextSize::Medium,
            weight: TextWeight::Normal,
        }
    }
    
    pub fn size(self, size: TextSize) -> Text {
        self.size = size
        self
    }
    
    pub fn bold(self) -> Text {
        self.weight = TextWeight::Bold
        self
    }
}

// Flex layout
pub struct Flex {
    children: Vec<UIElement>,
    direction: FlexDirection,
    gap: string,
}

pub enum FlexDirection {
    Row,
    Column,
}

impl Flex {
    pub fn new() -> Flex {
        Flex {
            children: Vec::new(),
            direction: FlexDirection::Row,
            gap: "8px",
        }
    }
    
    pub fn direction(self, dir: FlexDirection) -> Flex {
        self.direction = dir
        self
    }
    
    pub fn child(self, child: UIElement) -> Flex {
        self.children.push(child)
        self
    }
    
    pub fn gap(self, gap: string) -> Flex {
        self.gap = gap
        self
    }
}

// Panel (for sections)
pub struct Panel {
    title: string,
    children: Vec<UIElement>,
}

impl Panel {
    pub fn new(title: string) -> Panel {
        Panel {
            title: title,
            children: Vec::new(),
        }
    }
    
    pub fn child(self, child: UIElement) -> Panel {
        self.children.push(child)
        self
    }
}

// Alert (for errors, warnings, info)
pub struct Alert {
    message: string,
    variant: AlertVariant,
}

pub enum AlertVariant {
    Error,
    Warning,
    Info,
    Success,
}

impl Alert {
    pub fn error(message: string) -> Alert {
        Alert {
            message: message,
            variant: AlertVariant::Error,
        }
    }
    
    pub fn warning(message: string) -> Alert {
        Alert {
            message: message,
            variant: AlertVariant::Warning,
        }
    }
    
    pub fn info(message: string) -> Alert {
        Alert {
            message: message,
            variant: AlertVariant::Info,
        }
    }
    
    pub fn success(message: string) -> Alert {
        Alert {
            message: message,
            variant: AlertVariant::Success,
        }
    }
}

// UI Element (union type for all UI components)
pub enum UIElement {
    Button(Button),
    Container(Container),
    CodeEditor(CodeEditor),
    FileTree(FileTree),
    Input(Input),
    Text(Text),
    Flex(Flex),
    Panel(Panel),
    Alert(Alert),
}

// App structure
pub struct App {
    title: string,
    root: UIElement,
}

impl App {
    pub fn new(title: string, root: UIElement) -> App {
        App {
            title: title,
            root: root,
        }
    }
    
    pub fn run(self) {
        // This will be implemented by the Windjammer compiler
        // It will generate the appropriate Rust code to run the app
        // using windjammer-ui under the hood
    }
}

