// std/http - HTTP client and server with proper abstraction
// Implementation: reqwest (native client), TcpListener (native server), fetch API (browser client)

// PUBLIC API - Users interact with these functions only

pub type HttpResult<T> = Result<T, string>

// ============================================================================
// HTTP CLIENT API
// ============================================================================

/// HTTP Response
pub struct Response {
    pub status: int,
    pub headers: Vec<(string, string)>,
    pub body: string,
}

/// HTTP Request builder
pub struct Request {
    pub url: string,
    pub method: string,
    pub headers: Vec<(string, string)>,
    pub body: Option<string>,
    pub timeout: Option<int>, // seconds
}

impl Request {
    /// Create a new GET request
    pub fn get(url: string) -> Request {
        Request {
            url: url,
            method: "GET".to_string(),
            headers: vec![],
            body: None,
            timeout: None,
        }
    }
    
    /// Create a new POST request
    pub fn post(url: string, body: string) -> Request {
        Request {
            url: url,
            method: "POST".to_string(),
            headers: vec![],
            body: Some(body),
            timeout: None,
        }
    }
    
    /// Add a header
    pub fn header(mut self, key: string, value: string) -> Request {
        self.headers.push((key, value))
        self
    }
    
    /// Set timeout
    pub fn timeout(mut self, seconds: int) -> Request {
        self.timeout = Some(seconds)
        self
    }
    
    /// Send the request
    pub fn send(self) -> HttpResult<Response> {
        // Compiler will generate platform-specific code
        Err("Not implemented".to_string())
    }
}

/// Convenience functions for common HTTP methods
pub fn get(url: string) -> HttpResult<Response> {
    Request::get(url).send()
}

pub fn post(url: string, body: string) -> HttpResult<Response> {
    Request::post(url, body).send()
}

pub fn put(url: string, body: string) -> HttpResult<Response> {
    Request {
        url: url,
        method: "PUT".to_string(),
        headers: vec![],
        body: Some(body),
        timeout: None,
    }.send()
}

pub fn delete(url: string) -> HttpResult<Response> {
    Request {
        url: url,
        method: "DELETE".to_string(),
        headers: vec![],
        body: None,
        timeout: None,
    }.send()
}

// ============================================================================
// HTTP SERVER API
// ============================================================================

/// HTTP Server Request (received by server)
pub struct ServerRequest {
    pub method: string,
    pub path: string,
    pub headers: Vec<(string, string)>,
    pub body: string,
}

/// HTTP Server Response (sent by server)
pub struct ServerResponse {
    pub status: int,
    pub headers: Vec<(string, string)>,
    pub body: string,
    pub binary_body: Option<Vec<u8>>,  // For binary files like WASM, images
}

impl ServerResponse {
    /// Create a new response
    pub fn new(status: int, body: string) -> ServerResponse {
        ServerResponse {
            status: status,
            headers: vec![],
            body: body,
            binary_body: None,
        }
    }
    
    /// Create a binary response (for WASM, images, etc.)
    pub fn binary(status: int, data: Vec<u8>) -> ServerResponse {
        ServerResponse {
            status: status,
            headers: vec![],
            body: String::new(),
            binary_body: Some(data),
        }
    }
    
    /// Create an HTML response
    pub fn html(body: string) -> ServerResponse {
        ServerResponse {
            status: 200,
            headers: vec![("Content-Type".to_string(), "text/html".to_string())],
            body: body,
            binary_body: None,
        }
    }
    
    /// Create a JSON response
    pub fn json(body: string) -> ServerResponse {
        ServerResponse {
            status: 200,
            headers: vec![("Content-Type".to_string(), "application/json".to_string())],
            body: body,
            binary_body: None,
        }
    }
    
    /// Create an error response
    pub fn error(status: int, message: string) -> ServerResponse {
        ServerResponse {
            status: status,
            headers: vec![("Content-Type".to_string(), "text/plain".to_string())],
            body: message,
            binary_body: None,
        }
    }
    
    /// Add a header
    pub fn header(mut self, key: string, value: string) -> ServerResponse {
        self.headers.push((key, value))
        self
    }
}

/// HTTP Server
pub struct Server {
    pub address: string,
    pub port: int,
}

impl Server {
    /// Create a new server
    pub fn new(address: string, port: int) -> Server {
        Server {
            address: address,
            port: port,
        }
    }
    
    /// Start the server with a request handler
    /// The handler is called for each incoming request
    pub fn serve<F>(self, handler: F) -> HttpResult<()>
    where
        F: Fn(ServerRequest) -> ServerResponse
    {
        // Compiler will generate platform-specific code
        // Native: Use std::net::TcpListener
        // Browser: Not supported (servers can't run in browsers)
        Err("Not implemented".to_string())
    }
}

