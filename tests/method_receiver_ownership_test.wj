// Test that method receiver ownership is correctly inferred

// Test 1: Mutating self.field should infer &mut self
pub struct Counter {
    pub count: i32
}

impl Counter {
    pub fn new() -> Counter {
        Counter { count: 0 }
    }
    
    // Should infer &mut self because it mutates self.count
    pub fn increment(self) {
        self.count = self.count + 1
    }
    
    // Should infer &self because it only reads
    pub fn get(self) -> i32 {
        self.count
    }
}

// Test 2: Calling Vec::push should infer &mut self
pub struct TodoList {
    pub items: Vec<String>
}

impl TodoList {
    pub fn new() -> TodoList {
        TodoList { items: Vec::new() }
    }
    
    // Should infer &mut self because it calls push
    pub fn add_item(self, item: String) {
        self.items.push(item)
    }
    
    // Should infer &self because it only reads
    pub fn count(self) -> i32 {
        self.items.len() as i32
    }
}

// Test 3: Index assignment
pub struct Scores {
    pub values: Vec<i32>
}

impl Scores {
    pub fn new() -> Scores {
        Scores { values: Vec::new() }
    }
    
    // Should infer &mut self because it mutates vec element
    pub fn set_score(self, index: i32, value: i32) {
        self.values[index as int] = value
    }
}

// Test 4: Nested generics (Vec<Vec<T>>) - tests lexer fix for >> vs > >
pub struct Grid {
    pub rows: Vec<Vec<i32>>
}

impl Grid {
    pub fn new() -> Grid {
        Grid { rows: Vec::new() }
    }
    
    // Should infer &mut self because it mutates nested vec
    pub fn set_cell(self, row: i32, col: i32, value: i32) {
        self.rows[row as int][col as int] = value
    }
}

pub fn main() {
    let mut counter = Counter::new()
    counter.increment()
    counter.increment()
    
    let count = counter.get()
    println!("Count: {}", count)
    
    let mut todos = TodoList::new()
    todos.add_item("Fix compiler".to_string())
    todos.add_item("Run platformer".to_string())
    
    let total = todos.count()
    println!("Todos: {}", total)
}

