// Test: Module-qualified types should generate correct import paths
//
// Bug: Compiler treats each type as its own module
//   TextureAtlas → use super::texture_atlas::TextureAtlas  ❌ (not a module!)
//
// Should: Look up which module the type is defined in
//   TextureAtlas is in texture.wj → use super::texture::TextureAtlas  ✅

// Module 1: Define multiple types in one module
pub mod graphics {
    pub struct Texture {
        pub width: u32,
        pub height: u32,
    }

    pub struct TextureAtlas {
        pub texture: Texture,
        pub regions: Vec<SpriteRegion>,
    }

    pub struct SpriteRegion {
        pub x: u32,
        pub y: u32,
        pub width: u32,
        pub height: u32,
    }
}

// Module 2: Use types from graphics module
pub struct Sprite {
    pub texture: graphics::Texture,
    pub atlas: graphics::TextureAtlas,
    pub region: graphics::SpriteRegion,
}

impl Sprite {
    pub fn new() -> Sprite {
        let tex = graphics::Texture { width: 0, height: 0 };
        let region = graphics::SpriteRegion { x: 0, y: 0, width: 0, height: 0 };
        
        Sprite {
            texture: tex,
            atlas: graphics::TextureAtlas {
                texture: graphics::Texture { width: 0, height: 0 },
                regions: Vec::new(),
            },
            region: region,
        }
    }

    // Method with module-qualified parameter
    pub fn set_region(region: graphics::SpriteRegion) {
        self.region = region
    }
}

pub fn main() {
    let sprite = Sprite::new();
    println!("Sprite created");
}

